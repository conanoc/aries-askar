#if os(macOS)
import SystemConfiguration
#endif
// This file was autogenerated by some hot garbage in the `uniffi` crate.
// Trust me, you don't want to mess with it!
import Foundation

// Depending on the consumer's build setup, the low-level FFI code
// might be in a separate module, or it might be compiled inline into
// this module. This is a bit of light hackery to work with both.
#if canImport(aries_askarFFI)
    import aries_askarFFI
#endif

private extension RustBuffer {
    // Allocate a new buffer, copying the contents of a `UInt8` array.
    init(bytes: [UInt8]) {
        let rbuf = bytes.withUnsafeBufferPointer { ptr in
            RustBuffer.from(ptr)
        }
        self.init(capacity: rbuf.capacity, len: rbuf.len, data: rbuf.data)
    }

    static func from(_ ptr: UnsafeBufferPointer<UInt8>) -> RustBuffer {
        try! rustCall { ffi_aries_askar_rustbuffer_from_bytes(ForeignBytes(bufferPointer: ptr), $0) }
    }

    // Frees the buffer in place.
    // The buffer must not be used after this is called.
    func deallocate() {
        try! rustCall { ffi_aries_askar_rustbuffer_free(self, $0) }
    }
}

private extension ForeignBytes {
    init(bufferPointer: UnsafeBufferPointer<UInt8>) {
        self.init(len: Int32(bufferPointer.count), data: bufferPointer.baseAddress)
    }
}

// For every type used in the interface, we provide helper methods for conveniently
// lifting and lowering that type from C-compatible data, and for reading and writing
// values of that type in a buffer.

// Helper classes/extensions that don't change.
// Someday, this will be in a library of its own.

private extension Data {
    init(rustBuffer: RustBuffer) {
        // TODO: This copies the buffer. Can we read directly from a
        // Rust buffer?
        self.init(bytes: rustBuffer.data!, count: Int(rustBuffer.len))
    }
}

// Define reader functionality.  Normally this would be defined in a class or
// struct, but we use standalone functions instead in order to make external
// types work.
//
// With external types, one swift source file needs to be able to call the read
// method on another source file's FfiConverter, but then what visibility
// should Reader have?
// - If Reader is fileprivate, then this means the read() must also
//   be fileprivate, which doesn't work with external types.
// - If Reader is internal/public, we'll get compile errors since both source
//   files will try define the same type.
//
// Instead, the read() method and these helper functions input a tuple of data

private func createReader(data: Data) -> (data: Data, offset: Data.Index) {
    (data: data, offset: 0)
}

// Reads an integer at the current offset, in big-endian order, and advances
// the offset on success. Throws if reading the integer would move the
// offset past the end of the buffer.
private func readInt<T: FixedWidthInteger>(_ reader: inout (data: Data, offset: Data.Index)) throws -> T {
    let range = reader.offset ..< reader.offset + MemoryLayout<T>.size
    guard reader.data.count >= range.upperBound else {
        throw UniffiInternalError.bufferOverflow
    }
    if T.self == UInt8.self {
        let value = reader.data[reader.offset]
        reader.offset += 1
        return value as! T
    }
    var value: T = 0
    let _ = withUnsafeMutableBytes(of: &value) { reader.data.copyBytes(to: $0, from: range) }
    reader.offset = range.upperBound
    return value.bigEndian
}

// Reads an arbitrary number of bytes, to be used to read
// raw bytes, this is useful when lifting strings
private func readBytes(_ reader: inout (data: Data, offset: Data.Index), count: Int) throws -> [UInt8] {
    let range = reader.offset ..< (reader.offset + count)
    guard reader.data.count >= range.upperBound else {
        throw UniffiInternalError.bufferOverflow
    }
    var value = [UInt8](repeating: 0, count: count)
    value.withUnsafeMutableBufferPointer { buffer in
        reader.data.copyBytes(to: buffer, from: range)
    }
    reader.offset = range.upperBound
    return value
}

// Reads a float at the current offset.
private func readFloat(_ reader: inout (data: Data, offset: Data.Index)) throws -> Float {
    return try Float(bitPattern: readInt(&reader))
}

// Reads a float at the current offset.
private func readDouble(_ reader: inout (data: Data, offset: Data.Index)) throws -> Double {
    return try Double(bitPattern: readInt(&reader))
}

// Indicates if the offset has reached the end of the buffer.
private func hasRemaining(_ reader: (data: Data, offset: Data.Index)) -> Bool {
    return reader.offset < reader.data.count
}

// Define writer functionality.  Normally this would be defined in a class or
// struct, but we use standalone functions instead in order to make external
// types work.  See the above discussion on Readers for details.

private func createWriter() -> [UInt8] {
    return []
}

private func writeBytes<S>(_ writer: inout [UInt8], _ byteArr: S) where S: Sequence, S.Element == UInt8 {
    writer.append(contentsOf: byteArr)
}

// Writes an integer in big-endian order.
//
// Warning: make sure what you are trying to write
// is in the correct type!
private func writeInt<T: FixedWidthInteger>(_ writer: inout [UInt8], _ value: T) {
    var value = value.bigEndian
    withUnsafeBytes(of: &value) { writer.append(contentsOf: $0) }
}

private func writeFloat(_ writer: inout [UInt8], _ value: Float) {
    writeInt(&writer, value.bitPattern)
}

private func writeDouble(_ writer: inout [UInt8], _ value: Double) {
    writeInt(&writer, value.bitPattern)
}

// Protocol for types that transfer other types across the FFI. This is
// analogous go the Rust trait of the same name.
private protocol FfiConverter {
    associatedtype FfiType
    associatedtype SwiftType

    static func lift(_ value: FfiType) throws -> SwiftType
    static func lower(_ value: SwiftType) -> FfiType
    static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType
    static func write(_ value: SwiftType, into buf: inout [UInt8])
}

// Types conforming to `Primitive` pass themselves directly over the FFI.
private protocol FfiConverterPrimitive: FfiConverter where FfiType == SwiftType {}

extension FfiConverterPrimitive {
    public static func lift(_ value: FfiType) throws -> SwiftType {
        return value
    }

    public static func lower(_ value: SwiftType) -> FfiType {
        return value
    }
}

// Types conforming to `FfiConverterRustBuffer` lift and lower into a `RustBuffer`.
// Used for complex types where it's hard to write a custom lift/lower.
private protocol FfiConverterRustBuffer: FfiConverter where FfiType == RustBuffer {}

extension FfiConverterRustBuffer {
    public static func lift(_ buf: RustBuffer) throws -> SwiftType {
        var reader = createReader(data: Data(rustBuffer: buf))
        let value = try read(from: &reader)
        if hasRemaining(reader) {
            throw UniffiInternalError.incompleteData
        }
        buf.deallocate()
        return value
    }

    public static func lower(_ value: SwiftType) -> RustBuffer {
        var writer = createWriter()
        write(value, into: &writer)
        return RustBuffer(bytes: writer)
    }
}

// An error type for FFI errors. These errors occur at the UniFFI level, not
// the library level.
private enum UniffiInternalError: LocalizedError {
    case bufferOverflow
    case incompleteData
    case unexpectedOptionalTag
    case unexpectedEnumCase
    case unexpectedNullPointer
    case unexpectedRustCallStatusCode
    case unexpectedRustCallError
    case unexpectedStaleHandle
    case rustPanic(_ message: String)

    public var errorDescription: String? {
        switch self {
        case .bufferOverflow: return "Reading the requested value would read past the end of the buffer"
        case .incompleteData: return "The buffer still has data after lifting its containing value"
        case .unexpectedOptionalTag: return "Unexpected optional tag; should be 0 or 1"
        case .unexpectedEnumCase: return "Raw enum value doesn't match any cases"
        case .unexpectedNullPointer: return "Raw pointer value was null"
        case .unexpectedRustCallStatusCode: return "Unexpected RustCallStatus code"
        case .unexpectedRustCallError: return "CALL_ERROR but no errorClass specified"
        case .unexpectedStaleHandle: return "The object in the handle map has been dropped already"
        case let .rustPanic(message): return message
        }
    }
}

private let CALL_SUCCESS: Int8 = 0
private let CALL_ERROR: Int8 = 1
private let CALL_PANIC: Int8 = 2

private extension RustCallStatus {
    init() {
        self.init(
            code: CALL_SUCCESS,
            errorBuf: RustBuffer(
                capacity: 0,
                len: 0,
                data: nil
            )
        )
    }
}

private func rustCall<T>(_ callback: (UnsafeMutablePointer<RustCallStatus>) -> T) throws -> T {
    try makeRustCall(callback, errorHandler: {
        $0.deallocate()
        return UniffiInternalError.unexpectedRustCallError
    })
}

private func rustCallWithError<T, F: FfiConverter>
(_ errorFfiConverter: F.Type, _ callback: (UnsafeMutablePointer<RustCallStatus>) -> T) throws -> T
    where F.SwiftType: Error, F.FfiType == RustBuffer
{
    try makeRustCall(callback, errorHandler: { try errorFfiConverter.lift($0) })
}

private func makeRustCall<T>(_ callback: (UnsafeMutablePointer<RustCallStatus>) -> T, errorHandler: (RustBuffer) throws -> Error) throws -> T {
    uniffiCheckFfiVersionMismatch()
    var callStatus = RustCallStatus()
    let returnedVal = callback(&callStatus)
    switch callStatus.code {
    case CALL_SUCCESS:
        return returnedVal

    case CALL_ERROR:
        throw try errorHandler(callStatus.errorBuf)

    case CALL_PANIC:
        // When the rust code sees a panic, it tries to construct a RustBuffer
        // with the message.  But if that code panics, then it just sends back
        // an empty buffer.
        if callStatus.errorBuf.len > 0 {
            throw try UniffiInternalError.rustPanic(FfiConverterString.lift(callStatus.errorBuf))
        } else {
            callStatus.errorBuf.deallocate()
            throw UniffiInternalError.rustPanic("Rust panic")
        }

    default:
        throw UniffiInternalError.unexpectedRustCallStatusCode
    }
}

// Public interface members begin here.

private struct FfiConverterUInt8: FfiConverterPrimitive {
    typealias FfiType = UInt8
    typealias SwiftType = UInt8

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt8 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: UInt8, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

private struct FfiConverterInt32: FfiConverterPrimitive {
    typealias FfiType = Int32
    typealias SwiftType = Int32

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Int32 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: Int32, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

private struct FfiConverterInt64: FfiConverterPrimitive {
    typealias FfiType = Int64
    typealias SwiftType = Int64

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Int64 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: Int64, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

private struct FfiConverterBool: FfiConverter {
    typealias FfiType = Int8
    typealias SwiftType = Bool

    public static func lift(_ value: Int8) throws -> Bool {
        return value != 0
    }

    public static func lower(_ value: Bool) -> Int8 {
        return value ? 1 : 0
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Bool {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: Bool, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

private struct FfiConverterString: FfiConverter {
    typealias SwiftType = String
    typealias FfiType = RustBuffer

    public static func lift(_ value: RustBuffer) throws -> String {
        defer {
            value.deallocate()
        }
        if value.data == nil {
            return String()
        }
        let bytes = UnsafeBufferPointer<UInt8>(start: value.data!, count: Int(value.len))
        return String(bytes: bytes, encoding: String.Encoding.utf8)!
    }

    public static func lower(_ value: String) -> RustBuffer {
        return value.utf8CString.withUnsafeBufferPointer { ptr in
            // The swift string gives us int8_t, we want uint8_t.
            ptr.withMemoryRebound(to: UInt8.self) { ptr in
                // The swift string gives us a trailing null byte, we don't want it.
                let buf = UnsafeBufferPointer(rebasing: ptr.prefix(upTo: ptr.count - 1))
                return RustBuffer.from(buf)
            }
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> String {
        let len: Int32 = try readInt(&buf)
        return try String(bytes: readBytes(&buf, count: Int(len)), encoding: String.Encoding.utf8)!
    }

    public static func write(_ value: String, into buf: inout [UInt8]) {
        let len = Int32(value.utf8.count)
        writeInt(&buf, len)
        writeBytes(&buf, value.utf8)
    }
}

public protocol AskarCryptoProtocol {
    func boxOpen(receiverKey: AskarLocalKey, senderKey: AskarLocalKey, message: [UInt8], nonce: [UInt8]) throws -> [UInt8]
    func boxSeal(receiverKey: AskarLocalKey, message: [UInt8]) throws -> [UInt8]
    func boxSealOpen(receiverKey: AskarLocalKey, ciphertext: [UInt8]) throws -> [UInt8]
    func cryptoBox(receiverKey: AskarLocalKey, senderKey: AskarLocalKey, message: [UInt8], nonce: [UInt8]) throws -> [UInt8]
    func randomNonce() throws -> [UInt8]
}

public class AskarCrypto: AskarCryptoProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    public convenience init() {
        self.init(unsafeFromRawPointer: try! rustCall {
            uniffi_aries_askar_fn_method_askarcrypto_new($0)
        })
    }

    deinit {
        try! rustCall { uniffi_aries_askar_fn_free_askarcrypto(pointer, $0) }
    }

    public func boxOpen(receiverKey: AskarLocalKey, senderKey: AskarLocalKey, message: [UInt8], nonce: [UInt8]) throws -> [UInt8] {
        return try FfiConverterSequenceUInt8.lift(
            rustCallWithError(FfiConverterTypeErrorCode.self) {
                uniffi_aries_askar_fn_method_askarcrypto_box_open(self.pointer,
                                                                  FfiConverterTypeAskarLocalKey.lower(receiverKey),
                                                                  FfiConverterTypeAskarLocalKey.lower(senderKey),
                                                                  FfiConverterSequenceUInt8.lower(message),
                                                                  FfiConverterSequenceUInt8.lower(nonce), $0)
            }
        )
    }

    public func boxSeal(receiverKey: AskarLocalKey, message: [UInt8]) throws -> [UInt8] {
        return try FfiConverterSequenceUInt8.lift(
            rustCallWithError(FfiConverterTypeErrorCode.self) {
                uniffi_aries_askar_fn_method_askarcrypto_box_seal(self.pointer,
                                                                  FfiConverterTypeAskarLocalKey.lower(receiverKey),
                                                                  FfiConverterSequenceUInt8.lower(message), $0)
            }
        )
    }

    public func boxSealOpen(receiverKey: AskarLocalKey, ciphertext: [UInt8]) throws -> [UInt8] {
        return try FfiConverterSequenceUInt8.lift(
            rustCallWithError(FfiConverterTypeErrorCode.self) {
                uniffi_aries_askar_fn_method_askarcrypto_box_seal_open(self.pointer,
                                                                       FfiConverterTypeAskarLocalKey.lower(receiverKey),
                                                                       FfiConverterSequenceUInt8.lower(ciphertext), $0)
            }
        )
    }

    public func cryptoBox(receiverKey: AskarLocalKey, senderKey: AskarLocalKey, message: [UInt8], nonce: [UInt8]) throws -> [UInt8] {
        return try FfiConverterSequenceUInt8.lift(
            rustCallWithError(FfiConverterTypeErrorCode.self) {
                uniffi_aries_askar_fn_method_askarcrypto_crypto_box(self.pointer,
                                                                    FfiConverterTypeAskarLocalKey.lower(receiverKey),
                                                                    FfiConverterTypeAskarLocalKey.lower(senderKey),
                                                                    FfiConverterSequenceUInt8.lower(message),
                                                                    FfiConverterSequenceUInt8.lower(nonce), $0)
            }
        )
    }

    public func randomNonce() throws -> [UInt8] {
        return try FfiConverterSequenceUInt8.lift(
            rustCallWithError(FfiConverterTypeErrorCode.self) {
                uniffi_aries_askar_fn_method_askarcrypto_random_nonce(self.pointer, $0)
            }
        )
    }
}

public struct FfiConverterTypeAskarCrypto: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = AskarCrypto

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AskarCrypto {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: AskarCrypto, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> AskarCrypto {
        return AskarCrypto(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: AskarCrypto) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}

public func FfiConverterTypeAskarCrypto_lift(_ pointer: UnsafeMutableRawPointer) throws -> AskarCrypto {
    return try FfiConverterTypeAskarCrypto.lift(pointer)
}

public func FfiConverterTypeAskarCrypto_lower(_ value: AskarCrypto) -> UnsafeMutableRawPointer {
    return FfiConverterTypeAskarCrypto.lower(value)
}

public protocol AskarEcdh1PUProtocol {
    func decryptDirect(encAlg: AskarKeyAlg, ephemeralKey: AskarLocalKey, senderKey: AskarLocalKey, receiverKey: AskarLocalKey, ciphertext: [UInt8], tag: [UInt8]?, nonce: [UInt8], aad: [UInt8]?) throws -> [UInt8]
    func deriveKey(encAlg: AskarKeyAlg, ephemeralKey: AskarLocalKey, senderKey: AskarLocalKey, receiverKey: AskarLocalKey, ccTag: [UInt8], receive: Bool) throws -> AskarLocalKey
    func encryptDirect(encAlg: AskarKeyAlg, ephemeralKey: AskarLocalKey, senderKey: AskarLocalKey, receiverKey: AskarLocalKey, message: [UInt8], nonce: [UInt8]?, aad: [UInt8]?) throws -> EncryptedBuffer
    func receiverUnwrapKey(wrapAlg: AskarKeyAlg, encAlg: AskarKeyAlg, ephemeralKey: AskarLocalKey, senderKey: AskarLocalKey, receiverKey: AskarLocalKey, ciphertext: [UInt8], ccTag: [UInt8], nonce: [UInt8]?, tag: [UInt8]?) throws -> AskarLocalKey
    func senderWrapKey(wrapAlg: AskarKeyAlg, ephemeralKey: AskarLocalKey, senderKey: AskarLocalKey, receiverKey: AskarLocalKey, cek: AskarLocalKey, ccTag: [UInt8]) throws -> EncryptedBuffer
}

public class AskarEcdh1Pu: AskarEcdh1PUProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    public convenience init(algId: String, apu: String, apv: String) {
        self.init(unsafeFromRawPointer: try! rustCall {
            uniffi_aries_askar_fn_method_askarecdh1pu_new(
                FfiConverterString.lower(algId),
                FfiConverterString.lower(apu),
                FfiConverterString.lower(apv), $0
            )
        })
    }

    deinit {
        try! rustCall { uniffi_aries_askar_fn_free_askarecdh1pu(pointer, $0) }
    }

    public func decryptDirect(encAlg: AskarKeyAlg, ephemeralKey: AskarLocalKey, senderKey: AskarLocalKey, receiverKey: AskarLocalKey, ciphertext: [UInt8], tag: [UInt8]?, nonce: [UInt8], aad: [UInt8]?) throws -> [UInt8] {
        return try FfiConverterSequenceUInt8.lift(
            rustCallWithError(FfiConverterTypeErrorCode.self) {
                uniffi_aries_askar_fn_method_askarecdh1pu_decrypt_direct(self.pointer,
                                                                         FfiConverterTypeAskarKeyAlg.lower(encAlg),
                                                                         FfiConverterTypeAskarLocalKey.lower(ephemeralKey),
                                                                         FfiConverterTypeAskarLocalKey.lower(senderKey),
                                                                         FfiConverterTypeAskarLocalKey.lower(receiverKey),
                                                                         FfiConverterSequenceUInt8.lower(ciphertext),
                                                                         FfiConverterOptionSequenceUInt8.lower(tag),
                                                                         FfiConverterSequenceUInt8.lower(nonce),
                                                                         FfiConverterOptionSequenceUInt8.lower(aad), $0)
            }
        )
    }

    public func deriveKey(encAlg: AskarKeyAlg, ephemeralKey: AskarLocalKey, senderKey: AskarLocalKey, receiverKey: AskarLocalKey, ccTag: [UInt8], receive: Bool) throws -> AskarLocalKey {
        return try FfiConverterTypeAskarLocalKey.lift(
            rustCallWithError(FfiConverterTypeErrorCode.self) {
                uniffi_aries_askar_fn_method_askarecdh1pu_derive_key(self.pointer,
                                                                     FfiConverterTypeAskarKeyAlg.lower(encAlg),
                                                                     FfiConverterTypeAskarLocalKey.lower(ephemeralKey),
                                                                     FfiConverterTypeAskarLocalKey.lower(senderKey),
                                                                     FfiConverterTypeAskarLocalKey.lower(receiverKey),
                                                                     FfiConverterSequenceUInt8.lower(ccTag),
                                                                     FfiConverterBool.lower(receive), $0)
            }
        )
    }

    public func encryptDirect(encAlg: AskarKeyAlg, ephemeralKey: AskarLocalKey, senderKey: AskarLocalKey, receiverKey: AskarLocalKey, message: [UInt8], nonce: [UInt8]?, aad: [UInt8]?) throws -> EncryptedBuffer {
        return try FfiConverterTypeEncryptedBuffer.lift(
            rustCallWithError(FfiConverterTypeErrorCode.self) {
                uniffi_aries_askar_fn_method_askarecdh1pu_encrypt_direct(self.pointer,
                                                                         FfiConverterTypeAskarKeyAlg.lower(encAlg),
                                                                         FfiConverterTypeAskarLocalKey.lower(ephemeralKey),
                                                                         FfiConverterTypeAskarLocalKey.lower(senderKey),
                                                                         FfiConverterTypeAskarLocalKey.lower(receiverKey),
                                                                         FfiConverterSequenceUInt8.lower(message),
                                                                         FfiConverterOptionSequenceUInt8.lower(nonce),
                                                                         FfiConverterOptionSequenceUInt8.lower(aad), $0)
            }
        )
    }

    public func receiverUnwrapKey(wrapAlg: AskarKeyAlg, encAlg: AskarKeyAlg, ephemeralKey: AskarLocalKey, senderKey: AskarLocalKey, receiverKey: AskarLocalKey, ciphertext: [UInt8], ccTag: [UInt8], nonce: [UInt8]?, tag: [UInt8]?) throws -> AskarLocalKey {
        return try FfiConverterTypeAskarLocalKey.lift(
            rustCallWithError(FfiConverterTypeErrorCode.self) {
                uniffi_aries_askar_fn_method_askarecdh1pu_receiver_unwrap_key(self.pointer,
                                                                              FfiConverterTypeAskarKeyAlg.lower(wrapAlg),
                                                                              FfiConverterTypeAskarKeyAlg.lower(encAlg),
                                                                              FfiConverterTypeAskarLocalKey.lower(ephemeralKey),
                                                                              FfiConverterTypeAskarLocalKey.lower(senderKey),
                                                                              FfiConverterTypeAskarLocalKey.lower(receiverKey),
                                                                              FfiConverterSequenceUInt8.lower(ciphertext),
                                                                              FfiConverterSequenceUInt8.lower(ccTag),
                                                                              FfiConverterOptionSequenceUInt8.lower(nonce),
                                                                              FfiConverterOptionSequenceUInt8.lower(tag), $0)
            }
        )
    }

    public func senderWrapKey(wrapAlg: AskarKeyAlg, ephemeralKey: AskarLocalKey, senderKey: AskarLocalKey, receiverKey: AskarLocalKey, cek: AskarLocalKey, ccTag: [UInt8]) throws -> EncryptedBuffer {
        return try FfiConverterTypeEncryptedBuffer.lift(
            rustCallWithError(FfiConverterTypeErrorCode.self) {
                uniffi_aries_askar_fn_method_askarecdh1pu_sender_wrap_key(self.pointer,
                                                                          FfiConverterTypeAskarKeyAlg.lower(wrapAlg),
                                                                          FfiConverterTypeAskarLocalKey.lower(ephemeralKey),
                                                                          FfiConverterTypeAskarLocalKey.lower(senderKey),
                                                                          FfiConverterTypeAskarLocalKey.lower(receiverKey),
                                                                          FfiConverterTypeAskarLocalKey.lower(cek),
                                                                          FfiConverterSequenceUInt8.lower(ccTag), $0)
            }
        )
    }
}

public struct FfiConverterTypeAskarEcdh1Pu: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = AskarEcdh1Pu

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AskarEcdh1Pu {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: AskarEcdh1Pu, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> AskarEcdh1Pu {
        return AskarEcdh1Pu(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: AskarEcdh1Pu) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}

public func FfiConverterTypeAskarEcdh1Pu_lift(_ pointer: UnsafeMutableRawPointer) throws -> AskarEcdh1Pu {
    return try FfiConverterTypeAskarEcdh1Pu.lift(pointer)
}

public func FfiConverterTypeAskarEcdh1Pu_lower(_ value: AskarEcdh1Pu) -> UnsafeMutableRawPointer {
    return FfiConverterTypeAskarEcdh1Pu.lower(value)
}

public protocol AskarEcdhEsProtocol {
    func decryptDirect(encAlg: AskarKeyAlg, ephemeralKey: AskarLocalKey, receiverKey: AskarLocalKey, ciphertext: [UInt8], tag: [UInt8]?, nonce: [UInt8], aad: [UInt8]?) throws -> [UInt8]
    func deriveKey(encAlg: AskarKeyAlg, ephemeralKey: AskarLocalKey, receiverKey: AskarLocalKey, receive: Bool) throws -> AskarLocalKey
    func encryptDirect(encAlg: AskarKeyAlg, ephemeralKey: AskarLocalKey, receiverKey: AskarLocalKey, message: [UInt8], nonce: [UInt8]?, aad: [UInt8]?) throws -> EncryptedBuffer
    func receiverUnwrapKey(wrapAlg: AskarKeyAlg, encAlg: AskarKeyAlg, ephemeralKey: AskarLocalKey, receiverKey: AskarLocalKey, ciphertext: [UInt8], nonce: [UInt8]?, tag: [UInt8]?) throws -> AskarLocalKey
    func senderWrapKey(wrapAlg: AskarKeyAlg, ephemeralKey: AskarLocalKey, receiverKey: AskarLocalKey, cek: AskarLocalKey) throws -> EncryptedBuffer
}

public class AskarEcdhEs: AskarEcdhEsProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    public convenience init(algId: String, apu: String, apv: String) {
        self.init(unsafeFromRawPointer: try! rustCall {
            uniffi_aries_askar_fn_method_askarecdhes_new(
                FfiConverterString.lower(algId),
                FfiConverterString.lower(apu),
                FfiConverterString.lower(apv), $0
            )
        })
    }

    deinit {
        try! rustCall { uniffi_aries_askar_fn_free_askarecdhes(pointer, $0) }
    }

    public func decryptDirect(encAlg: AskarKeyAlg, ephemeralKey: AskarLocalKey, receiverKey: AskarLocalKey, ciphertext: [UInt8], tag: [UInt8]?, nonce: [UInt8], aad: [UInt8]?) throws -> [UInt8] {
        return try FfiConverterSequenceUInt8.lift(
            rustCallWithError(FfiConverterTypeErrorCode.self) {
                uniffi_aries_askar_fn_method_askarecdhes_decrypt_direct(self.pointer,
                                                                        FfiConverterTypeAskarKeyAlg.lower(encAlg),
                                                                        FfiConverterTypeAskarLocalKey.lower(ephemeralKey),
                                                                        FfiConverterTypeAskarLocalKey.lower(receiverKey),
                                                                        FfiConverterSequenceUInt8.lower(ciphertext),
                                                                        FfiConverterOptionSequenceUInt8.lower(tag),
                                                                        FfiConverterSequenceUInt8.lower(nonce),
                                                                        FfiConverterOptionSequenceUInt8.lower(aad), $0)
            }
        )
    }

    public func deriveKey(encAlg: AskarKeyAlg, ephemeralKey: AskarLocalKey, receiverKey: AskarLocalKey, receive: Bool) throws -> AskarLocalKey {
        return try FfiConverterTypeAskarLocalKey.lift(
            rustCallWithError(FfiConverterTypeErrorCode.self) {
                uniffi_aries_askar_fn_method_askarecdhes_derive_key(self.pointer,
                                                                    FfiConverterTypeAskarKeyAlg.lower(encAlg),
                                                                    FfiConverterTypeAskarLocalKey.lower(ephemeralKey),
                                                                    FfiConverterTypeAskarLocalKey.lower(receiverKey),
                                                                    FfiConverterBool.lower(receive), $0)
            }
        )
    }

    public func encryptDirect(encAlg: AskarKeyAlg, ephemeralKey: AskarLocalKey, receiverKey: AskarLocalKey, message: [UInt8], nonce: [UInt8]?, aad: [UInt8]?) throws -> EncryptedBuffer {
        return try FfiConverterTypeEncryptedBuffer.lift(
            rustCallWithError(FfiConverterTypeErrorCode.self) {
                uniffi_aries_askar_fn_method_askarecdhes_encrypt_direct(self.pointer,
                                                                        FfiConverterTypeAskarKeyAlg.lower(encAlg),
                                                                        FfiConverterTypeAskarLocalKey.lower(ephemeralKey),
                                                                        FfiConverterTypeAskarLocalKey.lower(receiverKey),
                                                                        FfiConverterSequenceUInt8.lower(message),
                                                                        FfiConverterOptionSequenceUInt8.lower(nonce),
                                                                        FfiConverterOptionSequenceUInt8.lower(aad), $0)
            }
        )
    }

    public func receiverUnwrapKey(wrapAlg: AskarKeyAlg, encAlg: AskarKeyAlg, ephemeralKey: AskarLocalKey, receiverKey: AskarLocalKey, ciphertext: [UInt8], nonce: [UInt8]?, tag: [UInt8]?) throws -> AskarLocalKey {
        return try FfiConverterTypeAskarLocalKey.lift(
            rustCallWithError(FfiConverterTypeErrorCode.self) {
                uniffi_aries_askar_fn_method_askarecdhes_receiver_unwrap_key(self.pointer,
                                                                             FfiConverterTypeAskarKeyAlg.lower(wrapAlg),
                                                                             FfiConverterTypeAskarKeyAlg.lower(encAlg),
                                                                             FfiConverterTypeAskarLocalKey.lower(ephemeralKey),
                                                                             FfiConverterTypeAskarLocalKey.lower(receiverKey),
                                                                             FfiConverterSequenceUInt8.lower(ciphertext),
                                                                             FfiConverterOptionSequenceUInt8.lower(nonce),
                                                                             FfiConverterOptionSequenceUInt8.lower(tag), $0)
            }
        )
    }

    public func senderWrapKey(wrapAlg: AskarKeyAlg, ephemeralKey: AskarLocalKey, receiverKey: AskarLocalKey, cek: AskarLocalKey) throws -> EncryptedBuffer {
        return try FfiConverterTypeEncryptedBuffer.lift(
            rustCallWithError(FfiConverterTypeErrorCode.self) {
                uniffi_aries_askar_fn_method_askarecdhes_sender_wrap_key(self.pointer,
                                                                         FfiConverterTypeAskarKeyAlg.lower(wrapAlg),
                                                                         FfiConverterTypeAskarLocalKey.lower(ephemeralKey),
                                                                         FfiConverterTypeAskarLocalKey.lower(receiverKey),
                                                                         FfiConverterTypeAskarLocalKey.lower(cek), $0)
            }
        )
    }
}

public struct FfiConverterTypeAskarEcdhEs: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = AskarEcdhEs

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AskarEcdhEs {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: AskarEcdhEs, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> AskarEcdhEs {
        return AskarEcdhEs(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: AskarEcdhEs) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}

public func FfiConverterTypeAskarEcdhEs_lift(_ pointer: UnsafeMutableRawPointer) throws -> AskarEcdhEs {
    return try FfiConverterTypeAskarEcdhEs.lift(pointer)
}

public func FfiConverterTypeAskarEcdhEs_lower(_ value: AskarEcdhEs) -> UnsafeMutableRawPointer {
    return FfiConverterTypeAskarEcdhEs.lower(value)
}

public protocol AskarEntryProtocol {
    func category() -> String
    func name() -> String
    func tags() -> [String: String]
    func value() -> [UInt8]
}

public class AskarEntry: AskarEntryProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { uniffi_aries_askar_fn_free_askarentry(pointer, $0) }
    }

    public func category() -> String {
        return try! FfiConverterString.lift(
            try!
                rustCall {
                    uniffi_aries_askar_fn_method_askarentry_category(self.pointer, $0)
                }
        )
    }

    public func name() -> String {
        return try! FfiConverterString.lift(
            try!
                rustCall {
                    uniffi_aries_askar_fn_method_askarentry_name(self.pointer, $0)
                }
        )
    }

    public func tags() -> [String: String] {
        return try! FfiConverterDictionaryStringString.lift(
            try!
                rustCall {
                    uniffi_aries_askar_fn_method_askarentry_tags(self.pointer, $0)
                }
        )
    }

    public func value() -> [UInt8] {
        return try! FfiConverterSequenceUInt8.lift(
            try!
                rustCall {
                    uniffi_aries_askar_fn_method_askarentry_value(self.pointer, $0)
                }
        )
    }
}

public struct FfiConverterTypeAskarEntry: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = AskarEntry

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AskarEntry {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: AskarEntry, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> AskarEntry {
        return AskarEntry(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: AskarEntry) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}

public func FfiConverterTypeAskarEntry_lift(_ pointer: UnsafeMutableRawPointer) throws -> AskarEntry {
    return try FfiConverterTypeAskarEntry.lift(pointer)
}

public func FfiConverterTypeAskarEntry_lower(_ value: AskarEntry) -> UnsafeMutableRawPointer {
    return FfiConverterTypeAskarEntry.lower(value)
}

public protocol AskarKeyEntryProtocol {
    func algorithm() -> String?
    func isLocal() -> Bool
    func loadLocalKey() throws -> AskarLocalKey
    func metadata() -> String?
    func name() -> String
    func tags() -> [String: String]
}

public class AskarKeyEntry: AskarKeyEntryProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { uniffi_aries_askar_fn_free_askarkeyentry(pointer, $0) }
    }

    public func algorithm() -> String? {
        return try! FfiConverterOptionString.lift(
            try!
                rustCall {
                    uniffi_aries_askar_fn_method_askarkeyentry_algorithm(self.pointer, $0)
                }
        )
    }

    public func isLocal() -> Bool {
        return try! FfiConverterBool.lift(
            try!
                rustCall {
                    uniffi_aries_askar_fn_method_askarkeyentry_is_local(self.pointer, $0)
                }
        )
    }

    public func loadLocalKey() throws -> AskarLocalKey {
        return try FfiConverterTypeAskarLocalKey.lift(
            rustCallWithError(FfiConverterTypeErrorCode.self) {
                uniffi_aries_askar_fn_method_askarkeyentry_load_local_key(self.pointer, $0)
            }
        )
    }

    public func metadata() -> String? {
        return try! FfiConverterOptionString.lift(
            try!
                rustCall {
                    uniffi_aries_askar_fn_method_askarkeyentry_metadata(self.pointer, $0)
                }
        )
    }

    public func name() -> String {
        return try! FfiConverterString.lift(
            try!
                rustCall {
                    uniffi_aries_askar_fn_method_askarkeyentry_name(self.pointer, $0)
                }
        )
    }

    public func tags() -> [String: String] {
        return try! FfiConverterDictionaryStringString.lift(
            try!
                rustCall {
                    uniffi_aries_askar_fn_method_askarkeyentry_tags(self.pointer, $0)
                }
        )
    }
}

public struct FfiConverterTypeAskarKeyEntry: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = AskarKeyEntry

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AskarKeyEntry {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: AskarKeyEntry, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> AskarKeyEntry {
        return AskarKeyEntry(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: AskarKeyEntry) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}

public func FfiConverterTypeAskarKeyEntry_lift(_ pointer: UnsafeMutableRawPointer) throws -> AskarKeyEntry {
    return try FfiConverterTypeAskarKeyEntry.lift(pointer)
}

public func FfiConverterTypeAskarKeyEntry_lower(_ value: AskarKeyEntry) -> UnsafeMutableRawPointer {
    return FfiConverterTypeAskarKeyEntry.lower(value)
}

public protocol AskarLocalKeyProtocol {
    func aeadDecrypt(ciphertext: [UInt8], tag: [UInt8]?, nonce: [UInt8], aad: [UInt8]?) throws -> [UInt8]
    func aeadEncrypt(message: [UInt8], nonce: [UInt8]?, aad: [UInt8]?) throws -> EncryptedBuffer
    func aeadPadding(msgLen: Int32) -> Int32
    func aeadParams() throws -> AeadParams
    func aeadRandomNonce() throws -> [UInt8]
    func algorithm() -> AskarKeyAlg
    func convertKey(alg: AskarKeyAlg) throws -> AskarLocalKey
    func signMessage(message: [UInt8], sigType: String?) throws -> [UInt8]
    func toJwkPublic(alg: AskarKeyAlg?) throws -> String
    func toJwkSecret() throws -> [UInt8]
    func toJwkThumbprint(alg: AskarKeyAlg?) throws -> String
    func toJwkThumbprints() throws -> [String]
    func toKeyExchange(alg: AskarKeyAlg, pk: AskarLocalKey) throws -> AskarLocalKey
    func toPublicBytes() throws -> [UInt8]
    func toSecretBytes() throws -> [UInt8]
    func unwrapKey(alg: AskarKeyAlg, ciphertext: [UInt8], tag: [UInt8]?, nonce: [UInt8]?) throws -> AskarLocalKey
    func verifySignature(message: [UInt8], signature: [UInt8], sigType: String?) throws -> Bool
    func wrapKey(key: AskarLocalKey, nonce: [UInt8]?) throws -> EncryptedBuffer
}

public class AskarLocalKey: AskarLocalKeyProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { uniffi_aries_askar_fn_free_askarlocalkey(pointer, $0) }
    }

    public func aeadDecrypt(ciphertext: [UInt8], tag: [UInt8]?, nonce: [UInt8], aad: [UInt8]?) throws -> [UInt8] {
        return try FfiConverterSequenceUInt8.lift(
            rustCallWithError(FfiConverterTypeErrorCode.self) {
                uniffi_aries_askar_fn_method_askarlocalkey_aead_decrypt(self.pointer,
                                                                        FfiConverterSequenceUInt8.lower(ciphertext),
                                                                        FfiConverterOptionSequenceUInt8.lower(tag),
                                                                        FfiConverterSequenceUInt8.lower(nonce),
                                                                        FfiConverterOptionSequenceUInt8.lower(aad), $0)
            }
        )
    }

    public func aeadEncrypt(message: [UInt8], nonce: [UInt8]?, aad: [UInt8]?) throws -> EncryptedBuffer {
        return try FfiConverterTypeEncryptedBuffer.lift(
            rustCallWithError(FfiConverterTypeErrorCode.self) {
                uniffi_aries_askar_fn_method_askarlocalkey_aead_encrypt(self.pointer,
                                                                        FfiConverterSequenceUInt8.lower(message),
                                                                        FfiConverterOptionSequenceUInt8.lower(nonce),
                                                                        FfiConverterOptionSequenceUInt8.lower(aad), $0)
            }
        )
    }

    public func aeadPadding(msgLen: Int32) -> Int32 {
        return try! FfiConverterInt32.lift(
            try!
                rustCall {
                    uniffi_aries_askar_fn_method_askarlocalkey_aead_padding(self.pointer,
                                                                            FfiConverterInt32.lower(msgLen), $0)
                }
        )
    }

    public func aeadParams() throws -> AeadParams {
        return try FfiConverterTypeAeadParams.lift(
            rustCallWithError(FfiConverterTypeErrorCode.self) {
                uniffi_aries_askar_fn_method_askarlocalkey_aead_params(self.pointer, $0)
            }
        )
    }

    public func aeadRandomNonce() throws -> [UInt8] {
        return try FfiConverterSequenceUInt8.lift(
            rustCallWithError(FfiConverterTypeErrorCode.self) {
                uniffi_aries_askar_fn_method_askarlocalkey_aead_random_nonce(self.pointer, $0)
            }
        )
    }

    public func algorithm() -> AskarKeyAlg {
        return try! FfiConverterTypeAskarKeyAlg.lift(
            try!
                rustCall {
                    uniffi_aries_askar_fn_method_askarlocalkey_algorithm(self.pointer, $0)
                }
        )
    }

    public func convertKey(alg: AskarKeyAlg) throws -> AskarLocalKey {
        return try FfiConverterTypeAskarLocalKey.lift(
            rustCallWithError(FfiConverterTypeErrorCode.self) {
                uniffi_aries_askar_fn_method_askarlocalkey_convert_key(self.pointer,
                                                                       FfiConverterTypeAskarKeyAlg.lower(alg), $0)
            }
        )
    }

    public func signMessage(message: [UInt8], sigType: String?) throws -> [UInt8] {
        return try FfiConverterSequenceUInt8.lift(
            rustCallWithError(FfiConverterTypeErrorCode.self) {
                uniffi_aries_askar_fn_method_askarlocalkey_sign_message(self.pointer,
                                                                        FfiConverterSequenceUInt8.lower(message),
                                                                        FfiConverterOptionString.lower(sigType), $0)
            }
        )
    }

    public func toJwkPublic(alg: AskarKeyAlg?) throws -> String {
        return try FfiConverterString.lift(
            rustCallWithError(FfiConverterTypeErrorCode.self) {
                uniffi_aries_askar_fn_method_askarlocalkey_to_jwk_public(self.pointer,
                                                                         FfiConverterOptionTypeAskarKeyAlg.lower(alg), $0)
            }
        )
    }

    public func toJwkSecret() throws -> [UInt8] {
        return try FfiConverterSequenceUInt8.lift(
            rustCallWithError(FfiConverterTypeErrorCode.self) {
                uniffi_aries_askar_fn_method_askarlocalkey_to_jwk_secret(self.pointer, $0)
            }
        )
    }

    public func toJwkThumbprint(alg: AskarKeyAlg?) throws -> String {
        return try FfiConverterString.lift(
            rustCallWithError(FfiConverterTypeErrorCode.self) {
                uniffi_aries_askar_fn_method_askarlocalkey_to_jwk_thumbprint(self.pointer,
                                                                             FfiConverterOptionTypeAskarKeyAlg.lower(alg), $0)
            }
        )
    }

    public func toJwkThumbprints() throws -> [String] {
        return try FfiConverterSequenceString.lift(
            rustCallWithError(FfiConverterTypeErrorCode.self) {
                uniffi_aries_askar_fn_method_askarlocalkey_to_jwk_thumbprints(self.pointer, $0)
            }
        )
    }

    public func toKeyExchange(alg: AskarKeyAlg, pk: AskarLocalKey) throws -> AskarLocalKey {
        return try FfiConverterTypeAskarLocalKey.lift(
            rustCallWithError(FfiConverterTypeErrorCode.self) {
                uniffi_aries_askar_fn_method_askarlocalkey_to_key_exchange(self.pointer,
                                                                           FfiConverterTypeAskarKeyAlg.lower(alg),
                                                                           FfiConverterTypeAskarLocalKey.lower(pk), $0)
            }
        )
    }

    public func toPublicBytes() throws -> [UInt8] {
        return try FfiConverterSequenceUInt8.lift(
            rustCallWithError(FfiConverterTypeErrorCode.self) {
                uniffi_aries_askar_fn_method_askarlocalkey_to_public_bytes(self.pointer, $0)
            }
        )
    }

    public func toSecretBytes() throws -> [UInt8] {
        return try FfiConverterSequenceUInt8.lift(
            rustCallWithError(FfiConverterTypeErrorCode.self) {
                uniffi_aries_askar_fn_method_askarlocalkey_to_secret_bytes(self.pointer, $0)
            }
        )
    }

    public func unwrapKey(alg: AskarKeyAlg, ciphertext: [UInt8], tag: [UInt8]?, nonce: [UInt8]?) throws -> AskarLocalKey {
        return try FfiConverterTypeAskarLocalKey.lift(
            rustCallWithError(FfiConverterTypeErrorCode.self) {
                uniffi_aries_askar_fn_method_askarlocalkey_unwrap_key(self.pointer,
                                                                      FfiConverterTypeAskarKeyAlg.lower(alg),
                                                                      FfiConverterSequenceUInt8.lower(ciphertext),
                                                                      FfiConverterOptionSequenceUInt8.lower(tag),
                                                                      FfiConverterOptionSequenceUInt8.lower(nonce), $0)
            }
        )
    }

    public func verifySignature(message: [UInt8], signature: [UInt8], sigType: String?) throws -> Bool {
        return try FfiConverterBool.lift(
            rustCallWithError(FfiConverterTypeErrorCode.self) {
                uniffi_aries_askar_fn_method_askarlocalkey_verify_signature(self.pointer,
                                                                            FfiConverterSequenceUInt8.lower(message),
                                                                            FfiConverterSequenceUInt8.lower(signature),
                                                                            FfiConverterOptionString.lower(sigType), $0)
            }
        )
    }

    public func wrapKey(key: AskarLocalKey, nonce: [UInt8]?) throws -> EncryptedBuffer {
        return try FfiConverterTypeEncryptedBuffer.lift(
            rustCallWithError(FfiConverterTypeErrorCode.self) {
                uniffi_aries_askar_fn_method_askarlocalkey_wrap_key(self.pointer,
                                                                    FfiConverterTypeAskarLocalKey.lower(key),
                                                                    FfiConverterOptionSequenceUInt8.lower(nonce), $0)
            }
        )
    }
}

public struct FfiConverterTypeAskarLocalKey: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = AskarLocalKey

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AskarLocalKey {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: AskarLocalKey, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> AskarLocalKey {
        return AskarLocalKey(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: AskarLocalKey) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}

public func FfiConverterTypeAskarLocalKey_lift(_ pointer: UnsafeMutableRawPointer) throws -> AskarLocalKey {
    return try FfiConverterTypeAskarLocalKey.lift(pointer)
}

public func FfiConverterTypeAskarLocalKey_lower(_ value: AskarLocalKey) -> UnsafeMutableRawPointer {
    return FfiConverterTypeAskarLocalKey.lower(value)
}

public protocol AskarScanProtocol {
    func fetchAll() async throws -> [AskarEntry]
    func next() async throws -> [AskarEntry]?
}

public class AskarScan: AskarScanProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { uniffi_aries_askar_fn_free_askarscan(pointer, $0) }
    }

    public func fetchAll() async throws -> [AskarEntry] {
        let future = try
            rustCallWithError(FfiConverterTypeErrorCode.self) {
                uniffi_aries_askar_fn_method_askarscan_fetch_all(self.pointer, $0)
            }

        return try await withCheckedThrowingContinuation { continuation in
            let env = Unmanaged.passRetained(_UniFFI_AskarScan_FetchAll_Env(rustyFuture: future, continuation: continuation))
            _UniFFI_AskarScan_FetchAll_waker(raw_env: env.toOpaque())
        }
    }

    public func next() async throws -> [AskarEntry]? {
        let future = try
            rustCallWithError(FfiConverterTypeErrorCode.self) {
                uniffi_aries_askar_fn_method_askarscan_next(self.pointer, $0)
            }

        return try await withCheckedThrowingContinuation { continuation in
            let env = Unmanaged.passRetained(_UniFFI_AskarScan_Next_Env(rustyFuture: future, continuation: continuation))
            _UniFFI_AskarScan_Next_waker(raw_env: env.toOpaque())
        }
    }
}

private class _UniFFI_AskarScan_FetchAll_Env {
    var rustFuture: OpaquePointer
    var continuation: CheckedContinuation<[AskarEntry], Error>

    init(rustyFuture: OpaquePointer, continuation: CheckedContinuation<[AskarEntry], Error>) {
        rustFuture = rustyFuture
        self.continuation = continuation
    }

    deinit {
        try! rustCall {
            uniffi_aries_askar_fn_method_askarscan_fetch_all_drop(self.rustFuture, $0)
        }
    }
}

private func _UniFFI_AskarScan_FetchAll_waker(raw_env: UnsafeMutableRawPointer?) {
    Task {
        let env = Unmanaged<_UniFFI_AskarScan_FetchAll_Env>.fromOpaque(raw_env!)
        let env_ref = env.takeUnretainedValue()
        let polledResult = UnsafeMutablePointer<RustBuffer>.allocate(capacity: 1)
        do {
            let isReady = try rustCallWithError(FfiConverterTypeErrorCode.self) {
                uniffi_aries_askar_fn_method_askarscan_fetch_all_poll(
                    env_ref.rustFuture,
                    _UniFFI_AskarScan_FetchAll_waker,
                    env.toOpaque(),
                    polledResult,
                    $0
                )
            }

            if isReady {
                env_ref.continuation.resume(returning: try! FfiConverterSequenceTypeAskarEntry.lift(polledResult.move()))
                polledResult.deallocate()
                env.release()
            }
        } catch {
            env_ref.continuation.resume(throwing: error)
            polledResult.deallocate()
            env.release()
        }
    }
}

private class _UniFFI_AskarScan_Next_Env {
    var rustFuture: OpaquePointer
    var continuation: CheckedContinuation<[AskarEntry]?, Error>

    init(rustyFuture: OpaquePointer, continuation: CheckedContinuation<[AskarEntry]?, Error>) {
        rustFuture = rustyFuture
        self.continuation = continuation
    }

    deinit {
        try! rustCall {
            uniffi_aries_askar_fn_method_askarscan_next_drop(self.rustFuture, $0)
        }
    }
}

private func _UniFFI_AskarScan_Next_waker(raw_env: UnsafeMutableRawPointer?) {
    Task {
        let env = Unmanaged<_UniFFI_AskarScan_Next_Env>.fromOpaque(raw_env!)
        let env_ref = env.takeUnretainedValue()
        let polledResult = UnsafeMutablePointer<RustBuffer>.allocate(capacity: 1)
        do {
            let isReady = try rustCallWithError(FfiConverterTypeErrorCode.self) {
                uniffi_aries_askar_fn_method_askarscan_next_poll(
                    env_ref.rustFuture,
                    _UniFFI_AskarScan_Next_waker,
                    env.toOpaque(),
                    polledResult,
                    $0
                )
            }

            if isReady {
                env_ref.continuation.resume(returning: try! FfiConverterOptionSequenceTypeAskarEntry.lift(polledResult.move()))
                polledResult.deallocate()
                env.release()
            }
        } catch {
            env_ref.continuation.resume(throwing: error)
            polledResult.deallocate()
            env.release()
        }
    }
}

public struct FfiConverterTypeAskarScan: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = AskarScan

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AskarScan {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: AskarScan, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> AskarScan {
        return AskarScan(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: AskarScan) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}

public func FfiConverterTypeAskarScan_lift(_ pointer: UnsafeMutableRawPointer) throws -> AskarScan {
    return try FfiConverterTypeAskarScan.lift(pointer)
}

public func FfiConverterTypeAskarScan_lower(_ value: AskarScan) -> UnsafeMutableRawPointer {
    return FfiConverterTypeAskarScan.lower(value)
}

public protocol AskarSessionProtocol {
    func count(category: String, tagFilter: String?) async throws -> Int64
    func fetch(category: String, name: String, forUpdate: Bool) async throws -> AskarEntry?
    func fetchAll(category: String, tagFilter: String?, limit: Int64?, forUpdate: Bool) async throws -> [AskarEntry]
    func fetchAllKeys(algorithm: String?, thumbprint: String?, tagFilter: String?, limit: Int64?, forUpdate: Bool) async throws -> [AskarKeyEntry]
    func fetchKey(name: String, forUpdate: Bool) async throws -> AskarKeyEntry?
    func insertKey(name: String, key: AskarLocalKey, metadata: String?, tags: String?, expiryMs: Int64?) async throws
    func removeAll(category: String, tagFilter: String?) async throws -> Int64
    func removeKey(name: String) async throws
    func update(operation: AskarEntryOperation, category: String, name: String, value: [UInt8], tags: String?, expiryMs: Int64?) async throws
    func updateKey(name: String, metadata: String?, tags: String?, expiryMs: Int64?) async throws
}

public class AskarSession: AskarSessionProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { uniffi_aries_askar_fn_free_askarsession(pointer, $0) }
    }

    public func count(category: String, tagFilter: String?) async throws -> Int64 {
        let future = try
            rustCallWithError(FfiConverterTypeErrorCode.self) {
                uniffi_aries_askar_fn_method_askarsession_count(self.pointer,
                                                                FfiConverterString.lower(category),
                                                                FfiConverterOptionString.lower(tagFilter), $0)
            }

        return try await withCheckedThrowingContinuation { continuation in
            let env = Unmanaged.passRetained(_UniFFI_AskarSession_Count_Env(rustyFuture: future, continuation: continuation))
            _UniFFI_AskarSession_Count_waker(raw_env: env.toOpaque())
        }
    }

    public func fetch(category: String, name: String, forUpdate: Bool) async throws -> AskarEntry? {
        let future = try
            rustCallWithError(FfiConverterTypeErrorCode.self) {
                uniffi_aries_askar_fn_method_askarsession_fetch(self.pointer,
                                                                FfiConverterString.lower(category),
                                                                FfiConverterString.lower(name),
                                                                FfiConverterBool.lower(forUpdate), $0)
            }

        return try await withCheckedThrowingContinuation { continuation in
            let env = Unmanaged.passRetained(_UniFFI_AskarSession_Fetch_Env(rustyFuture: future, continuation: continuation))
            _UniFFI_AskarSession_Fetch_waker(raw_env: env.toOpaque())
        }
    }

    public func fetchAll(category: String, tagFilter: String?, limit: Int64?, forUpdate: Bool) async throws -> [AskarEntry] {
        let future = try
            rustCallWithError(FfiConverterTypeErrorCode.self) {
                uniffi_aries_askar_fn_method_askarsession_fetch_all(self.pointer,
                                                                    FfiConverterString.lower(category),
                                                                    FfiConverterOptionString.lower(tagFilter),
                                                                    FfiConverterOptionInt64.lower(limit),
                                                                    FfiConverterBool.lower(forUpdate), $0)
            }

        return try await withCheckedThrowingContinuation { continuation in
            let env = Unmanaged.passRetained(_UniFFI_AskarSession_FetchAll_Env(rustyFuture: future, continuation: continuation))
            _UniFFI_AskarSession_FetchAll_waker(raw_env: env.toOpaque())
        }
    }

    public func fetchAllKeys(algorithm: String?, thumbprint: String?, tagFilter: String?, limit: Int64?, forUpdate: Bool) async throws -> [AskarKeyEntry] {
        let future = try
            rustCallWithError(FfiConverterTypeErrorCode.self) {
                uniffi_aries_askar_fn_method_askarsession_fetch_all_keys(self.pointer,
                                                                         FfiConverterOptionString.lower(algorithm),
                                                                         FfiConverterOptionString.lower(thumbprint),
                                                                         FfiConverterOptionString.lower(tagFilter),
                                                                         FfiConverterOptionInt64.lower(limit),
                                                                         FfiConverterBool.lower(forUpdate), $0)
            }

        return try await withCheckedThrowingContinuation { continuation in
            let env = Unmanaged.passRetained(_UniFFI_AskarSession_FetchAllKeys_Env(rustyFuture: future, continuation: continuation))
            _UniFFI_AskarSession_FetchAllKeys_waker(raw_env: env.toOpaque())
        }
    }

    public func fetchKey(name: String, forUpdate: Bool) async throws -> AskarKeyEntry? {
        let future = try
            rustCallWithError(FfiConverterTypeErrorCode.self) {
                uniffi_aries_askar_fn_method_askarsession_fetch_key(self.pointer,
                                                                    FfiConverterString.lower(name),
                                                                    FfiConverterBool.lower(forUpdate), $0)
            }

        return try await withCheckedThrowingContinuation { continuation in
            let env = Unmanaged.passRetained(_UniFFI_AskarSession_FetchKey_Env(rustyFuture: future, continuation: continuation))
            _UniFFI_AskarSession_FetchKey_waker(raw_env: env.toOpaque())
        }
    }

    public func insertKey(name: String, key: AskarLocalKey, metadata: String?, tags: String?, expiryMs: Int64?) async throws {
        let future = try
            rustCallWithError(FfiConverterTypeErrorCode.self) {
                uniffi_aries_askar_fn_method_askarsession_insert_key(self.pointer,
                                                                     FfiConverterString.lower(name),
                                                                     FfiConverterTypeAskarLocalKey.lower(key),
                                                                     FfiConverterOptionString.lower(metadata),
                                                                     FfiConverterOptionString.lower(tags),
                                                                     FfiConverterOptionInt64.lower(expiryMs), $0)
            }

        return try await withCheckedThrowingContinuation { continuation in
            let env = Unmanaged.passRetained(_UniFFI_AskarSession_InsertKey_Env(rustyFuture: future, continuation: continuation))
            _UniFFI_AskarSession_InsertKey_waker(raw_env: env.toOpaque())
        }
    }

    public func removeAll(category: String, tagFilter: String?) async throws -> Int64 {
        let future = try
            rustCallWithError(FfiConverterTypeErrorCode.self) {
                uniffi_aries_askar_fn_method_askarsession_remove_all(self.pointer,
                                                                     FfiConverterString.lower(category),
                                                                     FfiConverterOptionString.lower(tagFilter), $0)
            }

        return try await withCheckedThrowingContinuation { continuation in
            let env = Unmanaged.passRetained(_UniFFI_AskarSession_RemoveAll_Env(rustyFuture: future, continuation: continuation))
            _UniFFI_AskarSession_RemoveAll_waker(raw_env: env.toOpaque())
        }
    }

    public func removeKey(name: String) async throws {
        let future = try
            rustCallWithError(FfiConverterTypeErrorCode.self) {
                uniffi_aries_askar_fn_method_askarsession_remove_key(self.pointer,
                                                                     FfiConverterString.lower(name), $0)
            }

        return try await withCheckedThrowingContinuation { continuation in
            let env = Unmanaged.passRetained(_UniFFI_AskarSession_RemoveKey_Env(rustyFuture: future, continuation: continuation))
            _UniFFI_AskarSession_RemoveKey_waker(raw_env: env.toOpaque())
        }
    }

    public func update(operation: AskarEntryOperation, category: String, name: String, value: [UInt8], tags: String?, expiryMs: Int64?) async throws {
        let future = try
            rustCallWithError(FfiConverterTypeErrorCode.self) {
                uniffi_aries_askar_fn_method_askarsession_update(self.pointer,
                                                                 FfiConverterTypeAskarEntryOperation.lower(operation),
                                                                 FfiConverterString.lower(category),
                                                                 FfiConverterString.lower(name),
                                                                 FfiConverterSequenceUInt8.lower(value),
                                                                 FfiConverterOptionString.lower(tags),
                                                                 FfiConverterOptionInt64.lower(expiryMs), $0)
            }

        return try await withCheckedThrowingContinuation { continuation in
            let env = Unmanaged.passRetained(_UniFFI_AskarSession_Update_Env(rustyFuture: future, continuation: continuation))
            _UniFFI_AskarSession_Update_waker(raw_env: env.toOpaque())
        }
    }

    public func updateKey(name: String, metadata: String?, tags: String?, expiryMs: Int64?) async throws {
        let future = try
            rustCallWithError(FfiConverterTypeErrorCode.self) {
                uniffi_aries_askar_fn_method_askarsession_update_key(self.pointer,
                                                                     FfiConverterString.lower(name),
                                                                     FfiConverterOptionString.lower(metadata),
                                                                     FfiConverterOptionString.lower(tags),
                                                                     FfiConverterOptionInt64.lower(expiryMs), $0)
            }

        return try await withCheckedThrowingContinuation { continuation in
            let env = Unmanaged.passRetained(_UniFFI_AskarSession_UpdateKey_Env(rustyFuture: future, continuation: continuation))
            _UniFFI_AskarSession_UpdateKey_waker(raw_env: env.toOpaque())
        }
    }
}

private class _UniFFI_AskarSession_Count_Env {
    var rustFuture: OpaquePointer
    var continuation: CheckedContinuation<Int64, Error>

    init(rustyFuture: OpaquePointer, continuation: CheckedContinuation<Int64, Error>) {
        rustFuture = rustyFuture
        self.continuation = continuation
    }

    deinit {
        try! rustCall {
            uniffi_aries_askar_fn_method_askarsession_count_drop(self.rustFuture, $0)
        }
    }
}

private func _UniFFI_AskarSession_Count_waker(raw_env: UnsafeMutableRawPointer?) {
    Task {
        let env = Unmanaged<_UniFFI_AskarSession_Count_Env>.fromOpaque(raw_env!)
        let env_ref = env.takeUnretainedValue()
        let polledResult = UnsafeMutablePointer<Int64>.allocate(capacity: 1)
        do {
            let isReady = try rustCallWithError(FfiConverterTypeErrorCode.self) {
                uniffi_aries_askar_fn_method_askarsession_count_poll(
                    env_ref.rustFuture,
                    _UniFFI_AskarSession_Count_waker,
                    env.toOpaque(),
                    polledResult,
                    $0
                )
            }

            if isReady {
                env_ref.continuation.resume(returning: try! FfiConverterInt64.lift(polledResult.move()))
                polledResult.deallocate()
                env.release()
            }
        } catch {
            env_ref.continuation.resume(throwing: error)
            polledResult.deallocate()
            env.release()
        }
    }
}

private class _UniFFI_AskarSession_Fetch_Env {
    var rustFuture: OpaquePointer
    var continuation: CheckedContinuation<AskarEntry?, Error>

    init(rustyFuture: OpaquePointer, continuation: CheckedContinuation<AskarEntry?, Error>) {
        rustFuture = rustyFuture
        self.continuation = continuation
    }

    deinit {
        try! rustCall {
            uniffi_aries_askar_fn_method_askarsession_fetch_drop(self.rustFuture, $0)
        }
    }
}

private func _UniFFI_AskarSession_Fetch_waker(raw_env: UnsafeMutableRawPointer?) {
    Task {
        let env = Unmanaged<_UniFFI_AskarSession_Fetch_Env>.fromOpaque(raw_env!)
        let env_ref = env.takeUnretainedValue()
        let polledResult = UnsafeMutablePointer<RustBuffer>.allocate(capacity: 1)
        do {
            let isReady = try rustCallWithError(FfiConverterTypeErrorCode.self) {
                uniffi_aries_askar_fn_method_askarsession_fetch_poll(
                    env_ref.rustFuture,
                    _UniFFI_AskarSession_Fetch_waker,
                    env.toOpaque(),
                    polledResult,
                    $0
                )
            }

            if isReady {
                env_ref.continuation.resume(returning: try! FfiConverterOptionTypeAskarEntry.lift(polledResult.move()))
                polledResult.deallocate()
                env.release()
            }
        } catch {
            env_ref.continuation.resume(throwing: error)
            polledResult.deallocate()
            env.release()
        }
    }
}

private class _UniFFI_AskarSession_FetchAll_Env {
    var rustFuture: OpaquePointer
    var continuation: CheckedContinuation<[AskarEntry], Error>

    init(rustyFuture: OpaquePointer, continuation: CheckedContinuation<[AskarEntry], Error>) {
        rustFuture = rustyFuture
        self.continuation = continuation
    }

    deinit {
        try! rustCall {
            uniffi_aries_askar_fn_method_askarsession_fetch_all_drop(self.rustFuture, $0)
        }
    }
}

private func _UniFFI_AskarSession_FetchAll_waker(raw_env: UnsafeMutableRawPointer?) {
    Task {
        let env = Unmanaged<_UniFFI_AskarSession_FetchAll_Env>.fromOpaque(raw_env!)
        let env_ref = env.takeUnretainedValue()
        let polledResult = UnsafeMutablePointer<RustBuffer>.allocate(capacity: 1)
        do {
            let isReady = try rustCallWithError(FfiConverterTypeErrorCode.self) {
                uniffi_aries_askar_fn_method_askarsession_fetch_all_poll(
                    env_ref.rustFuture,
                    _UniFFI_AskarSession_FetchAll_waker,
                    env.toOpaque(),
                    polledResult,
                    $0
                )
            }

            if isReady {
                env_ref.continuation.resume(returning: try! FfiConverterSequenceTypeAskarEntry.lift(polledResult.move()))
                polledResult.deallocate()
                env.release()
            }
        } catch {
            env_ref.continuation.resume(throwing: error)
            polledResult.deallocate()
            env.release()
        }
    }
}

private class _UniFFI_AskarSession_FetchAllKeys_Env {
    var rustFuture: OpaquePointer
    var continuation: CheckedContinuation<[AskarKeyEntry], Error>

    init(rustyFuture: OpaquePointer, continuation: CheckedContinuation<[AskarKeyEntry], Error>) {
        rustFuture = rustyFuture
        self.continuation = continuation
    }

    deinit {
        try! rustCall {
            uniffi_aries_askar_fn_method_askarsession_fetch_all_keys_drop(self.rustFuture, $0)
        }
    }
}

private func _UniFFI_AskarSession_FetchAllKeys_waker(raw_env: UnsafeMutableRawPointer?) {
    Task {
        let env = Unmanaged<_UniFFI_AskarSession_FetchAllKeys_Env>.fromOpaque(raw_env!)
        let env_ref = env.takeUnretainedValue()
        let polledResult = UnsafeMutablePointer<RustBuffer>.allocate(capacity: 1)
        do {
            let isReady = try rustCallWithError(FfiConverterTypeErrorCode.self) {
                uniffi_aries_askar_fn_method_askarsession_fetch_all_keys_poll(
                    env_ref.rustFuture,
                    _UniFFI_AskarSession_FetchAllKeys_waker,
                    env.toOpaque(),
                    polledResult,
                    $0
                )
            }

            if isReady {
                env_ref.continuation.resume(returning: try! FfiConverterSequenceTypeAskarKeyEntry.lift(polledResult.move()))
                polledResult.deallocate()
                env.release()
            }
        } catch {
            env_ref.continuation.resume(throwing: error)
            polledResult.deallocate()
            env.release()
        }
    }
}

private class _UniFFI_AskarSession_FetchKey_Env {
    var rustFuture: OpaquePointer
    var continuation: CheckedContinuation<AskarKeyEntry?, Error>

    init(rustyFuture: OpaquePointer, continuation: CheckedContinuation<AskarKeyEntry?, Error>) {
        rustFuture = rustyFuture
        self.continuation = continuation
    }

    deinit {
        try! rustCall {
            uniffi_aries_askar_fn_method_askarsession_fetch_key_drop(self.rustFuture, $0)
        }
    }
}

private func _UniFFI_AskarSession_FetchKey_waker(raw_env: UnsafeMutableRawPointer?) {
    Task {
        let env = Unmanaged<_UniFFI_AskarSession_FetchKey_Env>.fromOpaque(raw_env!)
        let env_ref = env.takeUnretainedValue()
        let polledResult = UnsafeMutablePointer<RustBuffer>.allocate(capacity: 1)
        do {
            let isReady = try rustCallWithError(FfiConverterTypeErrorCode.self) {
                uniffi_aries_askar_fn_method_askarsession_fetch_key_poll(
                    env_ref.rustFuture,
                    _UniFFI_AskarSession_FetchKey_waker,
                    env.toOpaque(),
                    polledResult,
                    $0
                )
            }

            if isReady {
                env_ref.continuation.resume(returning: try! FfiConverterOptionTypeAskarKeyEntry.lift(polledResult.move()))
                polledResult.deallocate()
                env.release()
            }
        } catch {
            env_ref.continuation.resume(throwing: error)
            polledResult.deallocate()
            env.release()
        }
    }
}

private class _UniFFI_AskarSession_InsertKey_Env {
    var rustFuture: OpaquePointer
    var continuation: CheckedContinuation<Void, Error>

    init(rustyFuture: OpaquePointer, continuation: CheckedContinuation<Void, Error>) {
        rustFuture = rustyFuture
        self.continuation = continuation
    }

    deinit {
        try! rustCall {
            uniffi_aries_askar_fn_method_askarsession_insert_key_drop(self.rustFuture, $0)
        }
    }
}

private func _UniFFI_AskarSession_InsertKey_waker(raw_env: UnsafeMutableRawPointer?) {
    Task {
        let env = Unmanaged<_UniFFI_AskarSession_InsertKey_Env>.fromOpaque(raw_env!)
        let env_ref = env.takeUnretainedValue()
        let polledResult = UnsafeMutableRawPointer.allocate(byteCount: 0, alignment: 0)
        do {
            let isReady = try rustCallWithError(FfiConverterTypeErrorCode.self) {
                uniffi_aries_askar_fn_method_askarsession_insert_key_poll(
                    env_ref.rustFuture,
                    _UniFFI_AskarSession_InsertKey_waker,
                    env.toOpaque(),
                    polledResult,
                    $0
                )
            }

            if isReady {
                env_ref.continuation.resume(returning: ())
                polledResult.deallocate()
                env.release()
            }
        } catch {
            env_ref.continuation.resume(throwing: error)
            polledResult.deallocate()
            env.release()
        }
    }
}

private class _UniFFI_AskarSession_RemoveAll_Env {
    var rustFuture: OpaquePointer
    var continuation: CheckedContinuation<Int64, Error>

    init(rustyFuture: OpaquePointer, continuation: CheckedContinuation<Int64, Error>) {
        rustFuture = rustyFuture
        self.continuation = continuation
    }

    deinit {
        try! rustCall {
            uniffi_aries_askar_fn_method_askarsession_remove_all_drop(self.rustFuture, $0)
        }
    }
}

private func _UniFFI_AskarSession_RemoveAll_waker(raw_env: UnsafeMutableRawPointer?) {
    Task {
        let env = Unmanaged<_UniFFI_AskarSession_RemoveAll_Env>.fromOpaque(raw_env!)
        let env_ref = env.takeUnretainedValue()
        let polledResult = UnsafeMutablePointer<Int64>.allocate(capacity: 1)
        do {
            let isReady = try rustCallWithError(FfiConverterTypeErrorCode.self) {
                uniffi_aries_askar_fn_method_askarsession_remove_all_poll(
                    env_ref.rustFuture,
                    _UniFFI_AskarSession_RemoveAll_waker,
                    env.toOpaque(),
                    polledResult,
                    $0
                )
            }

            if isReady {
                env_ref.continuation.resume(returning: try! FfiConverterInt64.lift(polledResult.move()))
                polledResult.deallocate()
                env.release()
            }
        } catch {
            env_ref.continuation.resume(throwing: error)
            polledResult.deallocate()
            env.release()
        }
    }
}

private class _UniFFI_AskarSession_RemoveKey_Env {
    var rustFuture: OpaquePointer
    var continuation: CheckedContinuation<Void, Error>

    init(rustyFuture: OpaquePointer, continuation: CheckedContinuation<Void, Error>) {
        rustFuture = rustyFuture
        self.continuation = continuation
    }

    deinit {
        try! rustCall {
            uniffi_aries_askar_fn_method_askarsession_remove_key_drop(self.rustFuture, $0)
        }
    }
}

private func _UniFFI_AskarSession_RemoveKey_waker(raw_env: UnsafeMutableRawPointer?) {
    Task {
        let env = Unmanaged<_UniFFI_AskarSession_RemoveKey_Env>.fromOpaque(raw_env!)
        let env_ref = env.takeUnretainedValue()
        let polledResult = UnsafeMutableRawPointer.allocate(byteCount: 0, alignment: 0)
        do {
            let isReady = try rustCallWithError(FfiConverterTypeErrorCode.self) {
                uniffi_aries_askar_fn_method_askarsession_remove_key_poll(
                    env_ref.rustFuture,
                    _UniFFI_AskarSession_RemoveKey_waker,
                    env.toOpaque(),
                    polledResult,
                    $0
                )
            }

            if isReady {
                env_ref.continuation.resume(returning: ())
                polledResult.deallocate()
                env.release()
            }
        } catch {
            env_ref.continuation.resume(throwing: error)
            polledResult.deallocate()
            env.release()
        }
    }
}

private class _UniFFI_AskarSession_Update_Env {
    var rustFuture: OpaquePointer
    var continuation: CheckedContinuation<Void, Error>

    init(rustyFuture: OpaquePointer, continuation: CheckedContinuation<Void, Error>) {
        rustFuture = rustyFuture
        self.continuation = continuation
    }

    deinit {
        try! rustCall {
            uniffi_aries_askar_fn_method_askarsession_update_drop(self.rustFuture, $0)
        }
    }
}

private func _UniFFI_AskarSession_Update_waker(raw_env: UnsafeMutableRawPointer?) {
    Task {
        let env = Unmanaged<_UniFFI_AskarSession_Update_Env>.fromOpaque(raw_env!)
        let env_ref = env.takeUnretainedValue()
        let polledResult = UnsafeMutableRawPointer.allocate(byteCount: 0, alignment: 0)
        do {
            let isReady = try rustCallWithError(FfiConverterTypeErrorCode.self) {
                uniffi_aries_askar_fn_method_askarsession_update_poll(
                    env_ref.rustFuture,
                    _UniFFI_AskarSession_Update_waker,
                    env.toOpaque(),
                    polledResult,
                    $0
                )
            }

            if isReady {
                env_ref.continuation.resume(returning: ())
                polledResult.deallocate()
                env.release()
            }
        } catch {
            env_ref.continuation.resume(throwing: error)
            polledResult.deallocate()
            env.release()
        }
    }
}

private class _UniFFI_AskarSession_UpdateKey_Env {
    var rustFuture: OpaquePointer
    var continuation: CheckedContinuation<Void, Error>

    init(rustyFuture: OpaquePointer, continuation: CheckedContinuation<Void, Error>) {
        rustFuture = rustyFuture
        self.continuation = continuation
    }

    deinit {
        try! rustCall {
            uniffi_aries_askar_fn_method_askarsession_update_key_drop(self.rustFuture, $0)
        }
    }
}

private func _UniFFI_AskarSession_UpdateKey_waker(raw_env: UnsafeMutableRawPointer?) {
    Task {
        let env = Unmanaged<_UniFFI_AskarSession_UpdateKey_Env>.fromOpaque(raw_env!)
        let env_ref = env.takeUnretainedValue()
        let polledResult = UnsafeMutableRawPointer.allocate(byteCount: 0, alignment: 0)
        do {
            let isReady = try rustCallWithError(FfiConverterTypeErrorCode.self) {
                uniffi_aries_askar_fn_method_askarsession_update_key_poll(
                    env_ref.rustFuture,
                    _UniFFI_AskarSession_UpdateKey_waker,
                    env.toOpaque(),
                    polledResult,
                    $0
                )
            }

            if isReady {
                env_ref.continuation.resume(returning: ())
                polledResult.deallocate()
                env.release()
            }
        } catch {
            env_ref.continuation.resume(throwing: error)
            polledResult.deallocate()
            env.release()
        }
    }
}

public struct FfiConverterTypeAskarSession: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = AskarSession

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AskarSession {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: AskarSession, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> AskarSession {
        return AskarSession(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: AskarSession) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}

public func FfiConverterTypeAskarSession_lift(_ pointer: UnsafeMutableRawPointer) throws -> AskarSession {
    return try FfiConverterTypeAskarSession.lift(pointer)
}

public func FfiConverterTypeAskarSession_lower(_ value: AskarSession) -> UnsafeMutableRawPointer {
    return FfiConverterTypeAskarSession.lower(value)
}

public protocol AskarStoreProtocol {
    func close() async throws
    func createProfile(profile: String?) async throws -> String
    func getProfileName() throws -> String
    func rekey(keyMethod: String?, passKey: String?) async throws
    func removeProfile(profile: String) async throws -> Bool
    func scan(profile: String?, categogy: String, tagFilter: String?, offset: Int64?, limit: Int64?) async throws -> AskarScan
    func session(profile: String?) async throws -> AskarSession
}

public class AskarStore: AskarStoreProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { uniffi_aries_askar_fn_free_askarstore(pointer, $0) }
    }

    public func close() async throws {
        let future = try
            rustCallWithError(FfiConverterTypeErrorCode.self) {
                uniffi_aries_askar_fn_method_askarstore_close(self.pointer, $0)
            }

        return try await withCheckedThrowingContinuation { continuation in
            let env = Unmanaged.passRetained(_UniFFI_AskarStore_Close_Env(rustyFuture: future, continuation: continuation))
            _UniFFI_AskarStore_Close_waker(raw_env: env.toOpaque())
        }
    }

    public func createProfile(profile: String?) async throws -> String {
        let future = try
            rustCallWithError(FfiConverterTypeErrorCode.self) {
                uniffi_aries_askar_fn_method_askarstore_create_profile(self.pointer,
                                                                       FfiConverterOptionString.lower(profile), $0)
            }

        return try await withCheckedThrowingContinuation { continuation in
            let env = Unmanaged.passRetained(_UniFFI_AskarStore_CreateProfile_Env(rustyFuture: future, continuation: continuation))
            _UniFFI_AskarStore_CreateProfile_waker(raw_env: env.toOpaque())
        }
    }

    public func getProfileName() throws -> String {
        return try FfiConverterString.lift(
            rustCallWithError(FfiConverterTypeErrorCode.self) {
                uniffi_aries_askar_fn_method_askarstore_get_profile_name(self.pointer, $0)
            }
        )
    }

    public func rekey(keyMethod: String?, passKey: String?) async throws {
        let future = try
            rustCallWithError(FfiConverterTypeErrorCode.self) {
                uniffi_aries_askar_fn_method_askarstore_rekey(self.pointer,
                                                              FfiConverterOptionString.lower(keyMethod),
                                                              FfiConverterOptionString.lower(passKey), $0)
            }

        return try await withCheckedThrowingContinuation { continuation in
            let env = Unmanaged.passRetained(_UniFFI_AskarStore_Rekey_Env(rustyFuture: future, continuation: continuation))
            _UniFFI_AskarStore_Rekey_waker(raw_env: env.toOpaque())
        }
    }

    public func removeProfile(profile: String) async throws -> Bool {
        let future = try
            rustCallWithError(FfiConverterTypeErrorCode.self) {
                uniffi_aries_askar_fn_method_askarstore_remove_profile(self.pointer,
                                                                       FfiConverterString.lower(profile), $0)
            }

        return try await withCheckedThrowingContinuation { continuation in
            let env = Unmanaged.passRetained(_UniFFI_AskarStore_RemoveProfile_Env(rustyFuture: future, continuation: continuation))
            _UniFFI_AskarStore_RemoveProfile_waker(raw_env: env.toOpaque())
        }
    }

    public func scan(profile: String?, categogy: String, tagFilter: String?, offset: Int64?, limit: Int64?) async throws -> AskarScan {
        let future = try
            rustCallWithError(FfiConverterTypeErrorCode.self) {
                uniffi_aries_askar_fn_method_askarstore_scan(self.pointer,
                                                             FfiConverterOptionString.lower(profile),
                                                             FfiConverterString.lower(categogy),
                                                             FfiConverterOptionString.lower(tagFilter),
                                                             FfiConverterOptionInt64.lower(offset),
                                                             FfiConverterOptionInt64.lower(limit), $0)
            }

        return try await withCheckedThrowingContinuation { continuation in
            let env = Unmanaged.passRetained(_UniFFI_AskarStore_Scan_Env(rustyFuture: future, continuation: continuation))
            _UniFFI_AskarStore_Scan_waker(raw_env: env.toOpaque())
        }
    }

    public func session(profile: String?) async throws -> AskarSession {
        let future = try
            rustCallWithError(FfiConverterTypeErrorCode.self) {
                uniffi_aries_askar_fn_method_askarstore_session(self.pointer,
                                                                FfiConverterOptionString.lower(profile), $0)
            }

        return try await withCheckedThrowingContinuation { continuation in
            let env = Unmanaged.passRetained(_UniFFI_AskarStore_Session_Env(rustyFuture: future, continuation: continuation))
            _UniFFI_AskarStore_Session_waker(raw_env: env.toOpaque())
        }
    }
}

private class _UniFFI_AskarStore_Close_Env {
    var rustFuture: OpaquePointer
    var continuation: CheckedContinuation<Void, Error>

    init(rustyFuture: OpaquePointer, continuation: CheckedContinuation<Void, Error>) {
        rustFuture = rustyFuture
        self.continuation = continuation
    }

    deinit {
        try! rustCall {
            uniffi_aries_askar_fn_method_askarstore_close_drop(self.rustFuture, $0)
        }
    }
}

private func _UniFFI_AskarStore_Close_waker(raw_env: UnsafeMutableRawPointer?) {
    Task {
        let env = Unmanaged<_UniFFI_AskarStore_Close_Env>.fromOpaque(raw_env!)
        let env_ref = env.takeUnretainedValue()
        let polledResult = UnsafeMutableRawPointer.allocate(byteCount: 0, alignment: 0)
        do {
            let isReady = try rustCallWithError(FfiConverterTypeErrorCode.self) {
                uniffi_aries_askar_fn_method_askarstore_close_poll(
                    env_ref.rustFuture,
                    _UniFFI_AskarStore_Close_waker,
                    env.toOpaque(),
                    polledResult,
                    $0
                )
            }

            if isReady {
                env_ref.continuation.resume(returning: ())
                polledResult.deallocate()
                env.release()
            }
        } catch {
            env_ref.continuation.resume(throwing: error)
            polledResult.deallocate()
            env.release()
        }
    }
}

private class _UniFFI_AskarStore_CreateProfile_Env {
    var rustFuture: OpaquePointer
    var continuation: CheckedContinuation<String, Error>

    init(rustyFuture: OpaquePointer, continuation: CheckedContinuation<String, Error>) {
        rustFuture = rustyFuture
        self.continuation = continuation
    }

    deinit {
        try! rustCall {
            uniffi_aries_askar_fn_method_askarstore_create_profile_drop(self.rustFuture, $0)
        }
    }
}

private func _UniFFI_AskarStore_CreateProfile_waker(raw_env: UnsafeMutableRawPointer?) {
    Task {
        let env = Unmanaged<_UniFFI_AskarStore_CreateProfile_Env>.fromOpaque(raw_env!)
        let env_ref = env.takeUnretainedValue()
        let polledResult = UnsafeMutablePointer<RustBuffer>.allocate(capacity: 1)
        do {
            let isReady = try rustCallWithError(FfiConverterTypeErrorCode.self) {
                uniffi_aries_askar_fn_method_askarstore_create_profile_poll(
                    env_ref.rustFuture,
                    _UniFFI_AskarStore_CreateProfile_waker,
                    env.toOpaque(),
                    polledResult,
                    $0
                )
            }

            if isReady {
                env_ref.continuation.resume(returning: try! FfiConverterString.lift(polledResult.move()))
                polledResult.deallocate()
                env.release()
            }
        } catch {
            env_ref.continuation.resume(throwing: error)
            polledResult.deallocate()
            env.release()
        }
    }
}

private class _UniFFI_AskarStore_Rekey_Env {
    var rustFuture: OpaquePointer
    var continuation: CheckedContinuation<Void, Error>

    init(rustyFuture: OpaquePointer, continuation: CheckedContinuation<Void, Error>) {
        rustFuture = rustyFuture
        self.continuation = continuation
    }

    deinit {
        try! rustCall {
            uniffi_aries_askar_fn_method_askarstore_rekey_drop(self.rustFuture, $0)
        }
    }
}

private func _UniFFI_AskarStore_Rekey_waker(raw_env: UnsafeMutableRawPointer?) {
    Task {
        let env = Unmanaged<_UniFFI_AskarStore_Rekey_Env>.fromOpaque(raw_env!)
        let env_ref = env.takeUnretainedValue()
        let polledResult = UnsafeMutableRawPointer.allocate(byteCount: 0, alignment: 0)
        do {
            let isReady = try rustCallWithError(FfiConverterTypeErrorCode.self) {
                uniffi_aries_askar_fn_method_askarstore_rekey_poll(
                    env_ref.rustFuture,
                    _UniFFI_AskarStore_Rekey_waker,
                    env.toOpaque(),
                    polledResult,
                    $0
                )
            }

            if isReady {
                env_ref.continuation.resume(returning: ())
                polledResult.deallocate()
                env.release()
            }
        } catch {
            env_ref.continuation.resume(throwing: error)
            polledResult.deallocate()
            env.release()
        }
    }
}

private class _UniFFI_AskarStore_RemoveProfile_Env {
    var rustFuture: OpaquePointer
    var continuation: CheckedContinuation<Bool, Error>

    init(rustyFuture: OpaquePointer, continuation: CheckedContinuation<Bool, Error>) {
        rustFuture = rustyFuture
        self.continuation = continuation
    }

    deinit {
        try! rustCall {
            uniffi_aries_askar_fn_method_askarstore_remove_profile_drop(self.rustFuture, $0)
        }
    }
}

private func _UniFFI_AskarStore_RemoveProfile_waker(raw_env: UnsafeMutableRawPointer?) {
    Task {
        let env = Unmanaged<_UniFFI_AskarStore_RemoveProfile_Env>.fromOpaque(raw_env!)
        let env_ref = env.takeUnretainedValue()
        let polledResult = UnsafeMutablePointer<Int8>.allocate(capacity: 1)
        do {
            let isReady = try rustCallWithError(FfiConverterTypeErrorCode.self) {
                uniffi_aries_askar_fn_method_askarstore_remove_profile_poll(
                    env_ref.rustFuture,
                    _UniFFI_AskarStore_RemoveProfile_waker,
                    env.toOpaque(),
                    polledResult,
                    $0
                )
            }

            if isReady {
                env_ref.continuation.resume(returning: try! FfiConverterBool.lift(polledResult.move()))
                polledResult.deallocate()
                env.release()
            }
        } catch {
            env_ref.continuation.resume(throwing: error)
            polledResult.deallocate()
            env.release()
        }
    }
}

private class _UniFFI_AskarStore_Scan_Env {
    var rustFuture: OpaquePointer
    var continuation: CheckedContinuation<AskarScan, Error>

    init(rustyFuture: OpaquePointer, continuation: CheckedContinuation<AskarScan, Error>) {
        rustFuture = rustyFuture
        self.continuation = continuation
    }

    deinit {
        try! rustCall {
            uniffi_aries_askar_fn_method_askarstore_scan_drop(self.rustFuture, $0)
        }
    }
}

private func _UniFFI_AskarStore_Scan_waker(raw_env: UnsafeMutableRawPointer?) {
    Task {
        let env = Unmanaged<_UniFFI_AskarStore_Scan_Env>.fromOpaque(raw_env!)
        let env_ref = env.takeUnretainedValue()
        let polledResult = UnsafeMutablePointer <UnsafeMutableRawPointer>.allocate(capacity: 1)
        do {
            let isReady = try rustCallWithError(FfiConverterTypeErrorCode.self) {
                uniffi_aries_askar_fn_method_askarstore_scan_poll(
                    env_ref.rustFuture,
                    _UniFFI_AskarStore_Scan_waker,
                    env.toOpaque(),
                    polledResult,
                    $0
                )
            }

            if isReady {
                env_ref.continuation.resume(returning: try! FfiConverterTypeAskarScan.lift(polledResult.move()))
                polledResult.deallocate()
                env.release()
            }
        } catch {
            env_ref.continuation.resume(throwing: error)
            polledResult.deallocate()
            env.release()
        }
    }
}

private class _UniFFI_AskarStore_Session_Env {
    var rustFuture: OpaquePointer
    var continuation: CheckedContinuation<AskarSession, Error>

    init(rustyFuture: OpaquePointer, continuation: CheckedContinuation<AskarSession, Error>) {
        rustFuture = rustyFuture
        self.continuation = continuation
    }

    deinit {
        try! rustCall {
            uniffi_aries_askar_fn_method_askarstore_session_drop(self.rustFuture, $0)
        }
    }
}

private func _UniFFI_AskarStore_Session_waker(raw_env: UnsafeMutableRawPointer?) {
    Task {
        let env = Unmanaged<_UniFFI_AskarStore_Session_Env>.fromOpaque(raw_env!)
        let env_ref = env.takeUnretainedValue()
        let polledResult = UnsafeMutablePointer <UnsafeMutableRawPointer>.allocate(capacity: 1)
        do {
            let isReady = try rustCallWithError(FfiConverterTypeErrorCode.self) {
                uniffi_aries_askar_fn_method_askarstore_session_poll(
                    env_ref.rustFuture,
                    _UniFFI_AskarStore_Session_waker,
                    env.toOpaque(),
                    polledResult,
                    $0
                )
            }

            if isReady {
                env_ref.continuation.resume(returning: try! FfiConverterTypeAskarSession.lift(polledResult.move()))
                polledResult.deallocate()
                env.release()
            }
        } catch {
            env_ref.continuation.resume(throwing: error)
            polledResult.deallocate()
            env.release()
        }
    }
}

public struct FfiConverterTypeAskarStore: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = AskarStore

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AskarStore {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: AskarStore, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> AskarStore {
        return AskarStore(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: AskarStore) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}

public func FfiConverterTypeAskarStore_lift(_ pointer: UnsafeMutableRawPointer) throws -> AskarStore {
    return try FfiConverterTypeAskarStore.lift(pointer)
}

public func FfiConverterTypeAskarStore_lower(_ value: AskarStore) -> UnsafeMutableRawPointer {
    return FfiConverterTypeAskarStore.lower(value)
}

public protocol AskarStoreManagerProtocol {
    func generateRawStoreKey(seed: String?) throws -> String
    func open(specUri: String, keyMethod: String?, passKey: String?, profile: String?) async throws -> AskarStore
    func provision(specUri: String, keyMethod: String?, passKey: String?, profile: String?, recreate: Bool) async throws -> AskarStore
    func remove(specUri: String) async throws -> Bool
}

public class AskarStoreManager: AskarStoreManagerProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    public convenience init() {
        self.init(unsafeFromRawPointer: try! rustCall {
            uniffi_aries_askar_fn_method_askarstoremanager_new($0)
        })
    }

    deinit {
        try! rustCall { uniffi_aries_askar_fn_free_askarstoremanager(pointer, $0) }
    }

    public func generateRawStoreKey(seed: String?) throws -> String {
        return try FfiConverterString.lift(
            rustCallWithError(FfiConverterTypeErrorCode.self) {
                uniffi_aries_askar_fn_method_askarstoremanager_generate_raw_store_key(self.pointer,
                                                                                      FfiConverterOptionString.lower(seed), $0)
            }
        )
    }

    public func open(specUri: String, keyMethod: String?, passKey: String?, profile: String?) async throws -> AskarStore {
        let future = try
            rustCallWithError(FfiConverterTypeErrorCode.self) {
                uniffi_aries_askar_fn_method_askarstoremanager_open(self.pointer,
                                                                    FfiConverterString.lower(specUri),
                                                                    FfiConverterOptionString.lower(keyMethod),
                                                                    FfiConverterOptionString.lower(passKey),
                                                                    FfiConverterOptionString.lower(profile), $0)
            }

        return try await withCheckedThrowingContinuation { continuation in
            let env = Unmanaged.passRetained(_UniFFI_AskarStoreManager_Open_Env(rustyFuture: future, continuation: continuation))
            _UniFFI_AskarStoreManager_Open_waker(raw_env: env.toOpaque())
        }
    }

    public func provision(specUri: String, keyMethod: String?, passKey: String?, profile: String?, recreate: Bool) async throws -> AskarStore {
        let future = try
            rustCallWithError(FfiConverterTypeErrorCode.self) {
                uniffi_aries_askar_fn_method_askarstoremanager_provision(self.pointer,
                                                                         FfiConverterString.lower(specUri),
                                                                         FfiConverterOptionString.lower(keyMethod),
                                                                         FfiConverterOptionString.lower(passKey),
                                                                         FfiConverterOptionString.lower(profile),
                                                                         FfiConverterBool.lower(recreate), $0)
            }

        return try await withCheckedThrowingContinuation { continuation in
            let env = Unmanaged.passRetained(_UniFFI_AskarStoreManager_Provision_Env(rustyFuture: future, continuation: continuation))
            _UniFFI_AskarStoreManager_Provision_waker(raw_env: env.toOpaque())
        }
    }

    public func remove(specUri: String) async throws -> Bool {
        let future = try
            rustCallWithError(FfiConverterTypeErrorCode.self) {
                uniffi_aries_askar_fn_method_askarstoremanager_remove(self.pointer,
                                                                      FfiConverterString.lower(specUri), $0)
            }

        return try await withCheckedThrowingContinuation { continuation in
            let env = Unmanaged.passRetained(_UniFFI_AskarStoreManager_Remove_Env(rustyFuture: future, continuation: continuation))
            _UniFFI_AskarStoreManager_Remove_waker(raw_env: env.toOpaque())
        }
    }
}

private class _UniFFI_AskarStoreManager_Open_Env {
    var rustFuture: OpaquePointer
    var continuation: CheckedContinuation<AskarStore, Error>

    init(rustyFuture: OpaquePointer, continuation: CheckedContinuation<AskarStore, Error>) {
        rustFuture = rustyFuture
        self.continuation = continuation
    }

    deinit {
        try! rustCall {
            uniffi_aries_askar_fn_method_askarstoremanager_open_drop(self.rustFuture, $0)
        }
    }
}

private func _UniFFI_AskarStoreManager_Open_waker(raw_env: UnsafeMutableRawPointer?) {
    Task {
        let env = Unmanaged<_UniFFI_AskarStoreManager_Open_Env>.fromOpaque(raw_env!)
        let env_ref = env.takeUnretainedValue()
        let polledResult = UnsafeMutablePointer <UnsafeMutableRawPointer>.allocate(capacity: 1)
        do {
            let isReady = try rustCallWithError(FfiConverterTypeErrorCode.self) {
                uniffi_aries_askar_fn_method_askarstoremanager_open_poll(
                    env_ref.rustFuture,
                    _UniFFI_AskarStoreManager_Open_waker,
                    env.toOpaque(),
                    polledResult,
                    $0
                )
            }

            if isReady {
                env_ref.continuation.resume(returning: try! FfiConverterTypeAskarStore.lift(polledResult.move()))
                polledResult.deallocate()
                env.release()
            }
        } catch {
            env_ref.continuation.resume(throwing: error)
            polledResult.deallocate()
            env.release()
        }
    }
}

private class _UniFFI_AskarStoreManager_Provision_Env {
    var rustFuture: OpaquePointer
    var continuation: CheckedContinuation<AskarStore, Error>

    init(rustyFuture: OpaquePointer, continuation: CheckedContinuation<AskarStore, Error>) {
        rustFuture = rustyFuture
        self.continuation = continuation
    }

    deinit {
        try! rustCall {
            uniffi_aries_askar_fn_method_askarstoremanager_provision_drop(self.rustFuture, $0)
        }
    }
}

private func _UniFFI_AskarStoreManager_Provision_waker(raw_env: UnsafeMutableRawPointer?) {
    Task {
        let env = Unmanaged<_UniFFI_AskarStoreManager_Provision_Env>.fromOpaque(raw_env!)
        let env_ref = env.takeUnretainedValue()
        let polledResult = UnsafeMutablePointer <UnsafeMutableRawPointer>.allocate(capacity: 1)
        do {
            let isReady = try rustCallWithError(FfiConverterTypeErrorCode.self) {
                uniffi_aries_askar_fn_method_askarstoremanager_provision_poll(
                    env_ref.rustFuture,
                    _UniFFI_AskarStoreManager_Provision_waker,
                    env.toOpaque(),
                    polledResult,
                    $0
                )
            }

            if isReady {
                env_ref.continuation.resume(returning: try! FfiConverterTypeAskarStore.lift(polledResult.move()))
                polledResult.deallocate()
                env.release()
            }
        } catch {
            env_ref.continuation.resume(throwing: error)
            polledResult.deallocate()
            env.release()
        }
    }
}

private class _UniFFI_AskarStoreManager_Remove_Env {
    var rustFuture: OpaquePointer
    var continuation: CheckedContinuation<Bool, Error>

    init(rustyFuture: OpaquePointer, continuation: CheckedContinuation<Bool, Error>) {
        rustFuture = rustyFuture
        self.continuation = continuation
    }

    deinit {
        try! rustCall {
            uniffi_aries_askar_fn_method_askarstoremanager_remove_drop(self.rustFuture, $0)
        }
    }
}

private func _UniFFI_AskarStoreManager_Remove_waker(raw_env: UnsafeMutableRawPointer?) {
    Task {
        let env = Unmanaged<_UniFFI_AskarStoreManager_Remove_Env>.fromOpaque(raw_env!)
        let env_ref = env.takeUnretainedValue()
        let polledResult = UnsafeMutablePointer<Int8>.allocate(capacity: 1)
        do {
            let isReady = try rustCallWithError(FfiConverterTypeErrorCode.self) {
                uniffi_aries_askar_fn_method_askarstoremanager_remove_poll(
                    env_ref.rustFuture,
                    _UniFFI_AskarStoreManager_Remove_waker,
                    env.toOpaque(),
                    polledResult,
                    $0
                )
            }

            if isReady {
                env_ref.continuation.resume(returning: try! FfiConverterBool.lift(polledResult.move()))
                polledResult.deallocate()
                env.release()
            }
        } catch {
            env_ref.continuation.resume(throwing: error)
            polledResult.deallocate()
            env.release()
        }
    }
}

public struct FfiConverterTypeAskarStoreManager: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = AskarStoreManager

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AskarStoreManager {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: AskarStoreManager, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> AskarStoreManager {
        return AskarStoreManager(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: AskarStoreManager) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}

public func FfiConverterTypeAskarStoreManager_lift(_ pointer: UnsafeMutableRawPointer) throws -> AskarStoreManager {
    return try FfiConverterTypeAskarStoreManager.lift(pointer)
}

public func FfiConverterTypeAskarStoreManager_lower(_ value: AskarStoreManager) -> UnsafeMutableRawPointer {
    return FfiConverterTypeAskarStoreManager.lower(value)
}

public protocol EncryptedBufferProtocol {
    func ciphertext() -> [UInt8]
    func ciphertextTag() -> [UInt8]
    func nonce() -> [UInt8]
    func tag() -> [UInt8]
}

public class EncryptedBuffer: EncryptedBufferProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { uniffi_aries_askar_fn_free_encryptedbuffer(pointer, $0) }
    }

    public func ciphertext() -> [UInt8] {
        return try! FfiConverterSequenceUInt8.lift(
            try!
                rustCall {
                    uniffi_aries_askar_fn_method_encryptedbuffer_ciphertext(self.pointer, $0)
                }
        )
    }

    public func ciphertextTag() -> [UInt8] {
        return try! FfiConverterSequenceUInt8.lift(
            try!
                rustCall {
                    uniffi_aries_askar_fn_method_encryptedbuffer_ciphertext_tag(self.pointer, $0)
                }
        )
    }

    public func nonce() -> [UInt8] {
        return try! FfiConverterSequenceUInt8.lift(
            try!
                rustCall {
                    uniffi_aries_askar_fn_method_encryptedbuffer_nonce(self.pointer, $0)
                }
        )
    }

    public func tag() -> [UInt8] {
        return try! FfiConverterSequenceUInt8.lift(
            try!
                rustCall {
                    uniffi_aries_askar_fn_method_encryptedbuffer_tag(self.pointer, $0)
                }
        )
    }
}

public struct FfiConverterTypeEncryptedBuffer: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = EncryptedBuffer

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> EncryptedBuffer {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: EncryptedBuffer, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> EncryptedBuffer {
        return EncryptedBuffer(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: EncryptedBuffer) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}

public func FfiConverterTypeEncryptedBuffer_lift(_ pointer: UnsafeMutableRawPointer) throws -> EncryptedBuffer {
    return try FfiConverterTypeEncryptedBuffer.lift(pointer)
}

public func FfiConverterTypeEncryptedBuffer_lower(_ value: EncryptedBuffer) -> UnsafeMutableRawPointer {
    return FfiConverterTypeEncryptedBuffer.lower(value)
}

public protocol LocalKeyFactoryProtocol {
    func fromJwk(jwk: String) throws -> AskarLocalKey
    func fromJwkSlice(jwk: [UInt8]) throws -> AskarLocalKey
    func fromPublicBytes(alg: AskarKeyAlg, bytes: [UInt8]) throws -> AskarLocalKey
    func fromSecretBytes(alg: AskarKeyAlg, bytes: [UInt8]) throws -> AskarLocalKey
    func fromSeed(alg: AskarKeyAlg, seed: [UInt8], method: SeedMethod?) throws -> AskarLocalKey
    func generate(alg: AskarKeyAlg, ephemeral: Bool) throws -> AskarLocalKey
}

public class LocalKeyFactory: LocalKeyFactoryProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    public convenience init() {
        self.init(unsafeFromRawPointer: try! rustCall {
            uniffi_aries_askar_fn_method_localkeyfactory_new($0)
        })
    }

    deinit {
        try! rustCall { uniffi_aries_askar_fn_free_localkeyfactory(pointer, $0) }
    }

    public func fromJwk(jwk: String) throws -> AskarLocalKey {
        return try FfiConverterTypeAskarLocalKey.lift(
            rustCallWithError(FfiConverterTypeErrorCode.self) {
                uniffi_aries_askar_fn_method_localkeyfactory_from_jwk(self.pointer,
                                                                      FfiConverterString.lower(jwk), $0)
            }
        )
    }

    public func fromJwkSlice(jwk: [UInt8]) throws -> AskarLocalKey {
        return try FfiConverterTypeAskarLocalKey.lift(
            rustCallWithError(FfiConverterTypeErrorCode.self) {
                uniffi_aries_askar_fn_method_localkeyfactory_from_jwk_slice(self.pointer,
                                                                            FfiConverterSequenceUInt8.lower(jwk), $0)
            }
        )
    }

    public func fromPublicBytes(alg: AskarKeyAlg, bytes: [UInt8]) throws -> AskarLocalKey {
        return try FfiConverterTypeAskarLocalKey.lift(
            rustCallWithError(FfiConverterTypeErrorCode.self) {
                uniffi_aries_askar_fn_method_localkeyfactory_from_public_bytes(self.pointer,
                                                                               FfiConverterTypeAskarKeyAlg.lower(alg),
                                                                               FfiConverterSequenceUInt8.lower(bytes), $0)
            }
        )
    }

    public func fromSecretBytes(alg: AskarKeyAlg, bytes: [UInt8]) throws -> AskarLocalKey {
        return try FfiConverterTypeAskarLocalKey.lift(
            rustCallWithError(FfiConverterTypeErrorCode.self) {
                uniffi_aries_askar_fn_method_localkeyfactory_from_secret_bytes(self.pointer,
                                                                               FfiConverterTypeAskarKeyAlg.lower(alg),
                                                                               FfiConverterSequenceUInt8.lower(bytes), $0)
            }
        )
    }

    public func fromSeed(alg: AskarKeyAlg, seed: [UInt8], method: SeedMethod?) throws -> AskarLocalKey {
        return try FfiConverterTypeAskarLocalKey.lift(
            rustCallWithError(FfiConverterTypeErrorCode.self) {
                uniffi_aries_askar_fn_method_localkeyfactory_from_seed(self.pointer,
                                                                       FfiConverterTypeAskarKeyAlg.lower(alg),
                                                                       FfiConverterSequenceUInt8.lower(seed),
                                                                       FfiConverterOptionTypeSeedMethod.lower(method), $0)
            }
        )
    }

    public func generate(alg: AskarKeyAlg, ephemeral: Bool) throws -> AskarLocalKey {
        return try FfiConverterTypeAskarLocalKey.lift(
            rustCallWithError(FfiConverterTypeErrorCode.self) {
                uniffi_aries_askar_fn_method_localkeyfactory_generate(self.pointer,
                                                                      FfiConverterTypeAskarKeyAlg.lower(alg),
                                                                      FfiConverterBool.lower(ephemeral), $0)
            }
        )
    }
}

public struct FfiConverterTypeLocalKeyFactory: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = LocalKeyFactory

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LocalKeyFactory {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: LocalKeyFactory, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> LocalKeyFactory {
        return LocalKeyFactory(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: LocalKeyFactory) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}

public func FfiConverterTypeLocalKeyFactory_lift(_ pointer: UnsafeMutableRawPointer) throws -> LocalKeyFactory {
    return try FfiConverterTypeLocalKeyFactory.lift(pointer)
}

public func FfiConverterTypeLocalKeyFactory_lower(_ value: LocalKeyFactory) -> UnsafeMutableRawPointer {
    return FfiConverterTypeLocalKeyFactory.lower(value)
}

public struct AeadParams {
    public var nonceLength: Int32
    public var tagLength: Int32

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(nonceLength: Int32, tagLength: Int32) {
        self.nonceLength = nonceLength
        self.tagLength = tagLength
    }
}

extension AeadParams: Equatable, Hashable {
    public static func == (lhs: AeadParams, rhs: AeadParams) -> Bool {
        if lhs.nonceLength != rhs.nonceLength {
            return false
        }
        if lhs.tagLength != rhs.tagLength {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(nonceLength)
        hasher.combine(tagLength)
    }
}

public struct FfiConverterTypeAeadParams: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AeadParams {
        return try AeadParams(
            nonceLength: FfiConverterInt32.read(from: &buf),
            tagLength: FfiConverterInt32.read(from: &buf)
        )
    }

    public static func write(_ value: AeadParams, into buf: inout [UInt8]) {
        FfiConverterInt32.write(value.nonceLength, into: &buf)
        FfiConverterInt32.write(value.tagLength, into: &buf)
    }
}

public func FfiConverterTypeAeadParams_lift(_ buf: RustBuffer) throws -> AeadParams {
    return try FfiConverterTypeAeadParams.lift(buf)
}

public func FfiConverterTypeAeadParams_lower(_ value: AeadParams) -> RustBuffer {
    return FfiConverterTypeAeadParams.lower(value)
}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum AskarEntryOperation {
    case insert
    case replace
    case remove
}

public struct FfiConverterTypeAskarEntryOperation: FfiConverterRustBuffer {
    typealias SwiftType = AskarEntryOperation

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AskarEntryOperation {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return .insert

        case 2: return .replace

        case 3: return .remove

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: AskarEntryOperation, into buf: inout [UInt8]) {
        switch value {
        case .insert:
            writeInt(&buf, Int32(1))

        case .replace:
            writeInt(&buf, Int32(2))

        case .remove:
            writeInt(&buf, Int32(3))
        }
    }
}

public func FfiConverterTypeAskarEntryOperation_lift(_ buf: RustBuffer) throws -> AskarEntryOperation {
    return try FfiConverterTypeAskarEntryOperation.lift(buf)
}

public func FfiConverterTypeAskarEntryOperation_lower(_ value: AskarEntryOperation) -> RustBuffer {
    return FfiConverterTypeAskarEntryOperation.lower(value)
}

extension AskarEntryOperation: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum AskarKeyAlg {
    case a128Gcm
    case a256Gcm
    case a128CbcHs256
    case a256CbcHs512
    case a128Kw
    case a256Kw
    case bls12381g1
    case bls12381g2
    case bls12381g1g2
    case c20p
    case xc20p
    case ed25519
    case x25519
    case k256
    case p256
}

public struct FfiConverterTypeAskarKeyAlg: FfiConverterRustBuffer {
    typealias SwiftType = AskarKeyAlg

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AskarKeyAlg {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return .a128Gcm

        case 2: return .a256Gcm

        case 3: return .a128CbcHs256

        case 4: return .a256CbcHs512

        case 5: return .a128Kw

        case 6: return .a256Kw

        case 7: return .bls12381g1

        case 8: return .bls12381g2

        case 9: return .bls12381g1g2

        case 10: return .c20p

        case 11: return .xc20p

        case 12: return .ed25519

        case 13: return .x25519

        case 14: return .k256

        case 15: return .p256

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: AskarKeyAlg, into buf: inout [UInt8]) {
        switch value {
        case .a128Gcm:
            writeInt(&buf, Int32(1))

        case .a256Gcm:
            writeInt(&buf, Int32(2))

        case .a128CbcHs256:
            writeInt(&buf, Int32(3))

        case .a256CbcHs512:
            writeInt(&buf, Int32(4))

        case .a128Kw:
            writeInt(&buf, Int32(5))

        case .a256Kw:
            writeInt(&buf, Int32(6))

        case .bls12381g1:
            writeInt(&buf, Int32(7))

        case .bls12381g2:
            writeInt(&buf, Int32(8))

        case .bls12381g1g2:
            writeInt(&buf, Int32(9))

        case .c20p:
            writeInt(&buf, Int32(10))

        case .xc20p:
            writeInt(&buf, Int32(11))

        case .ed25519:
            writeInt(&buf, Int32(12))

        case .x25519:
            writeInt(&buf, Int32(13))

        case .k256:
            writeInt(&buf, Int32(14))

        case .p256:
            writeInt(&buf, Int32(15))
        }
    }
}

public func FfiConverterTypeAskarKeyAlg_lift(_ buf: RustBuffer) throws -> AskarKeyAlg {
    return try FfiConverterTypeAskarKeyAlg.lift(buf)
}

public func FfiConverterTypeAskarKeyAlg_lower(_ value: AskarKeyAlg) -> RustBuffer {
    return FfiConverterTypeAskarKeyAlg.lower(value)
}

extension AskarKeyAlg: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum SeedMethod {
    case blsKeyGen
}

public struct FfiConverterTypeSeedMethod: FfiConverterRustBuffer {
    typealias SwiftType = SeedMethod

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SeedMethod {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return .blsKeyGen

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: SeedMethod, into buf: inout [UInt8]) {
        switch value {
        case .blsKeyGen:
            writeInt(&buf, Int32(1))
        }
    }
}

public func FfiConverterTypeSeedMethod_lift(_ buf: RustBuffer) throws -> SeedMethod {
    return try FfiConverterTypeSeedMethod.lift(buf)
}

public func FfiConverterTypeSeedMethod_lower(_ value: SeedMethod) -> RustBuffer {
    return FfiConverterTypeSeedMethod.lower(value)
}

extension SeedMethod: Equatable, Hashable {}

public enum ErrorCode {
    case Success(message: String)
    case Backend(message: String)
    case Busy(message: String)
    case Duplicate(message: String)
    case Encryption(message: String)
    case Input(message: String)
    case NotFound(message: String)
    case Unexpected(message: String)
    case Unsupported(message: String)
    case Custom(message: String)
}

public struct FfiConverterTypeErrorCode: FfiConverterRustBuffer {
    typealias SwiftType = ErrorCode

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ErrorCode {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return try .Success(
                message: FfiConverterString.read(from: &buf)
            )
        case 2: return try .Backend(
                message: FfiConverterString.read(from: &buf)
            )
        case 3: return try .Busy(
                message: FfiConverterString.read(from: &buf)
            )
        case 4: return try .Duplicate(
                message: FfiConverterString.read(from: &buf)
            )
        case 5: return try .Encryption(
                message: FfiConverterString.read(from: &buf)
            )
        case 6: return try .Input(
                message: FfiConverterString.read(from: &buf)
            )
        case 7: return try .NotFound(
                message: FfiConverterString.read(from: &buf)
            )
        case 8: return try .Unexpected(
                message: FfiConverterString.read(from: &buf)
            )
        case 9: return try .Unsupported(
                message: FfiConverterString.read(from: &buf)
            )
        case 10: return try .Custom(
                message: FfiConverterString.read(from: &buf)
            )

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ErrorCode, into buf: inout [UInt8]) {
        switch value {
        case let .Success(message):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(message, into: &buf)

        case let .Backend(message):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(message, into: &buf)

        case let .Busy(message):
            writeInt(&buf, Int32(3))
            FfiConverterString.write(message, into: &buf)

        case let .Duplicate(message):
            writeInt(&buf, Int32(4))
            FfiConverterString.write(message, into: &buf)

        case let .Encryption(message):
            writeInt(&buf, Int32(5))
            FfiConverterString.write(message, into: &buf)

        case let .Input(message):
            writeInt(&buf, Int32(6))
            FfiConverterString.write(message, into: &buf)

        case let .NotFound(message):
            writeInt(&buf, Int32(7))
            FfiConverterString.write(message, into: &buf)

        case let .Unexpected(message):
            writeInt(&buf, Int32(8))
            FfiConverterString.write(message, into: &buf)

        case let .Unsupported(message):
            writeInt(&buf, Int32(9))
            FfiConverterString.write(message, into: &buf)

        case let .Custom(message):
            writeInt(&buf, Int32(10))
            FfiConverterString.write(message, into: &buf)
        }
    }
}

extension ErrorCode: Equatable, Hashable {}

extension ErrorCode: Error {}

private struct FfiConverterOptionInt64: FfiConverterRustBuffer {
    typealias SwiftType = Int64?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterInt64.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterInt64.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

private struct FfiConverterOptionString: FfiConverterRustBuffer {
    typealias SwiftType = String?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterString.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterString.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

private struct FfiConverterOptionTypeAskarEntry: FfiConverterRustBuffer {
    typealias SwiftType = AskarEntry?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeAskarEntry.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeAskarEntry.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

private struct FfiConverterOptionTypeAskarKeyEntry: FfiConverterRustBuffer {
    typealias SwiftType = AskarKeyEntry?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeAskarKeyEntry.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeAskarKeyEntry.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

private struct FfiConverterOptionTypeAskarKeyAlg: FfiConverterRustBuffer {
    typealias SwiftType = AskarKeyAlg?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeAskarKeyAlg.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeAskarKeyAlg.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

private struct FfiConverterOptionTypeSeedMethod: FfiConverterRustBuffer {
    typealias SwiftType = SeedMethod?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeSeedMethod.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeSeedMethod.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

private struct FfiConverterOptionSequenceUInt8: FfiConverterRustBuffer {
    typealias SwiftType = [UInt8]?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterSequenceUInt8.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterSequenceUInt8.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

private struct FfiConverterOptionSequenceTypeAskarEntry: FfiConverterRustBuffer {
    typealias SwiftType = [AskarEntry]?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterSequenceTypeAskarEntry.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterSequenceTypeAskarEntry.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

private struct FfiConverterSequenceUInt8: FfiConverterRustBuffer {
    typealias SwiftType = [UInt8]

    public static func write(_ value: [UInt8], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterUInt8.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [UInt8] {
        let len: Int32 = try readInt(&buf)
        var seq = [UInt8]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterUInt8.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceString: FfiConverterRustBuffer {
    typealias SwiftType = [String]

    public static func write(_ value: [String], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterString.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [String] {
        let len: Int32 = try readInt(&buf)
        var seq = [String]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterString.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypeAskarEntry: FfiConverterRustBuffer {
    typealias SwiftType = [AskarEntry]

    public static func write(_ value: [AskarEntry], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeAskarEntry.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [AskarEntry] {
        let len: Int32 = try readInt(&buf)
        var seq = [AskarEntry]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeAskarEntry.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypeAskarKeyEntry: FfiConverterRustBuffer {
    typealias SwiftType = [AskarKeyEntry]

    public static func write(_ value: [AskarKeyEntry], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeAskarKeyEntry.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [AskarKeyEntry] {
        let len: Int32 = try readInt(&buf)
        var seq = [AskarKeyEntry]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeAskarKeyEntry.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterDictionaryStringString: FfiConverterRustBuffer {
    public static func write(_ value: [String: String], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterString.write(key, into: &buf)
            FfiConverterString.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [String: String] {
        let len: Int32 = try readInt(&buf)
        var dict = [String: String]()
        dict.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            let key = try FfiConverterString.read(from: &buf)
            let value = try FfiConverterString.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}

private enum CheckVersionResult {
    case ok
    case contractVersionMismatch
    case apiChecksumMismatch
}

// Use a global variables to perform the versioning checks. Swift ensures that
// the code inside is only computed once.
private var checkVersionResult: CheckVersionResult {
    // Get the bindings contract version from our ComponentInterface
    let bindings_contract_version = 22
    // Get the scaffolding contract version by calling the into the dylib
    let scaffolding_contract_version = ffi_aries_askar_uniffi_contract_version()
    if bindings_contract_version != scaffolding_contract_version {
        return CheckVersionResult.contractVersionMismatch
    }
    if uniffi_aries_askar_checksum_method_askarentry_category() != 3260 {
        return CheckVersionResult.apiChecksumMismatch
    }
    if uniffi_aries_askar_checksum_method_askarentry_name() != 32165 {
        return CheckVersionResult.apiChecksumMismatch
    }
    if uniffi_aries_askar_checksum_method_askarentry_tags() != 25644 {
        return CheckVersionResult.apiChecksumMismatch
    }
    if uniffi_aries_askar_checksum_method_askarentry_value() != 15374 {
        return CheckVersionResult.apiChecksumMismatch
    }
    if uniffi_aries_askar_checksum_method_askarkeyentry_algorithm() != 49759 {
        return CheckVersionResult.apiChecksumMismatch
    }
    if uniffi_aries_askar_checksum_method_askarkeyentry_is_local() != 55452 {
        return CheckVersionResult.apiChecksumMismatch
    }
    if uniffi_aries_askar_checksum_method_askarkeyentry_load_local_key() != 48016 {
        return CheckVersionResult.apiChecksumMismatch
    }
    if uniffi_aries_askar_checksum_method_askarkeyentry_metadata() != 37970 {
        return CheckVersionResult.apiChecksumMismatch
    }
    if uniffi_aries_askar_checksum_method_askarkeyentry_name() != 37206 {
        return CheckVersionResult.apiChecksumMismatch
    }
    if uniffi_aries_askar_checksum_method_askarkeyentry_tags() != 44110 {
        return CheckVersionResult.apiChecksumMismatch
    }
    if uniffi_aries_askar_checksum_method_askarscan_fetch_all() != 49886 {
        return CheckVersionResult.apiChecksumMismatch
    }
    if uniffi_aries_askar_checksum_method_askarscan_next() != 24376 {
        return CheckVersionResult.apiChecksumMismatch
    }
    if uniffi_aries_askar_checksum_method_askarsession_count() != 1 {
        return CheckVersionResult.apiChecksumMismatch
    }
    if uniffi_aries_askar_checksum_method_askarsession_fetch() != 36317 {
        return CheckVersionResult.apiChecksumMismatch
    }
    if uniffi_aries_askar_checksum_method_askarsession_fetch_all() != 57565 {
        return CheckVersionResult.apiChecksumMismatch
    }
    if uniffi_aries_askar_checksum_method_askarsession_fetch_all_keys() != 16421 {
        return CheckVersionResult.apiChecksumMismatch
    }
    if uniffi_aries_askar_checksum_method_askarsession_fetch_key() != 39145 {
        return CheckVersionResult.apiChecksumMismatch
    }
    if uniffi_aries_askar_checksum_method_askarsession_insert_key() != 45535 {
        return CheckVersionResult.apiChecksumMismatch
    }
    if uniffi_aries_askar_checksum_method_askarsession_remove_all() != 32725 {
        return CheckVersionResult.apiChecksumMismatch
    }
    if uniffi_aries_askar_checksum_method_askarsession_remove_key() != 9007 {
        return CheckVersionResult.apiChecksumMismatch
    }
    if uniffi_aries_askar_checksum_method_askarsession_update() != 2672 {
        return CheckVersionResult.apiChecksumMismatch
    }
    if uniffi_aries_askar_checksum_method_askarsession_update_key() != 12783 {
        return CheckVersionResult.apiChecksumMismatch
    }
    if uniffi_aries_askar_checksum_method_askarstore_close() != 15140 {
        return CheckVersionResult.apiChecksumMismatch
    }
    if uniffi_aries_askar_checksum_method_askarstore_create_profile() != 27418 {
        return CheckVersionResult.apiChecksumMismatch
    }
    if uniffi_aries_askar_checksum_method_askarstore_get_profile_name() != 59164 {
        return CheckVersionResult.apiChecksumMismatch
    }
    if uniffi_aries_askar_checksum_method_askarstore_rekey() != 33417 {
        return CheckVersionResult.apiChecksumMismatch
    }
    if uniffi_aries_askar_checksum_method_askarstore_remove_profile() != 38282 {
        return CheckVersionResult.apiChecksumMismatch
    }
    if uniffi_aries_askar_checksum_method_askarstore_scan() != 14373 {
        return CheckVersionResult.apiChecksumMismatch
    }
    if uniffi_aries_askar_checksum_method_askarstore_session() != 50551 {
        return CheckVersionResult.apiChecksumMismatch
    }
    if uniffi_aries_askar_checksum_method_askarlocalkey_aead_decrypt() != 27175 {
        return CheckVersionResult.apiChecksumMismatch
    }
    if uniffi_aries_askar_checksum_method_askarlocalkey_aead_encrypt() != 59752 {
        return CheckVersionResult.apiChecksumMismatch
    }
    if uniffi_aries_askar_checksum_method_askarlocalkey_aead_padding() != 19466 {
        return CheckVersionResult.apiChecksumMismatch
    }
    if uniffi_aries_askar_checksum_method_askarlocalkey_aead_params() != 22595 {
        return CheckVersionResult.apiChecksumMismatch
    }
    if uniffi_aries_askar_checksum_method_askarlocalkey_aead_random_nonce() != 18087 {
        return CheckVersionResult.apiChecksumMismatch
    }
    if uniffi_aries_askar_checksum_method_askarlocalkey_algorithm() != 53705 {
        return CheckVersionResult.apiChecksumMismatch
    }
    if uniffi_aries_askar_checksum_method_askarlocalkey_convert_key() != 41434 {
        return CheckVersionResult.apiChecksumMismatch
    }
    if uniffi_aries_askar_checksum_method_askarlocalkey_sign_message() != 17995 {
        return CheckVersionResult.apiChecksumMismatch
    }
    if uniffi_aries_askar_checksum_method_askarlocalkey_to_jwk_public() != 56035 {
        return CheckVersionResult.apiChecksumMismatch
    }
    if uniffi_aries_askar_checksum_method_askarlocalkey_to_jwk_secret() != 56136 {
        return CheckVersionResult.apiChecksumMismatch
    }
    if uniffi_aries_askar_checksum_method_askarlocalkey_to_jwk_thumbprint() != 21833 {
        return CheckVersionResult.apiChecksumMismatch
    }
    if uniffi_aries_askar_checksum_method_askarlocalkey_to_jwk_thumbprints() != 60939 {
        return CheckVersionResult.apiChecksumMismatch
    }
    if uniffi_aries_askar_checksum_method_askarlocalkey_to_key_exchange() != 37112 {
        return CheckVersionResult.apiChecksumMismatch
    }
    if uniffi_aries_askar_checksum_method_askarlocalkey_to_public_bytes() != 31459 {
        return CheckVersionResult.apiChecksumMismatch
    }
    if uniffi_aries_askar_checksum_method_askarlocalkey_to_secret_bytes() != 23429 {
        return CheckVersionResult.apiChecksumMismatch
    }
    if uniffi_aries_askar_checksum_method_askarlocalkey_unwrap_key() != 8054 {
        return CheckVersionResult.apiChecksumMismatch
    }
    if uniffi_aries_askar_checksum_method_askarlocalkey_verify_signature() != 44262 {
        return CheckVersionResult.apiChecksumMismatch
    }
    if uniffi_aries_askar_checksum_method_askarlocalkey_wrap_key() != 53373 {
        return CheckVersionResult.apiChecksumMismatch
    }
    if uniffi_aries_askar_checksum_method_encryptedbuffer_ciphertext() != 25707 {
        return CheckVersionResult.apiChecksumMismatch
    }
    if uniffi_aries_askar_checksum_method_encryptedbuffer_ciphertext_tag() != 4068 {
        return CheckVersionResult.apiChecksumMismatch
    }
    if uniffi_aries_askar_checksum_method_encryptedbuffer_nonce() != 58146 {
        return CheckVersionResult.apiChecksumMismatch
    }
    if uniffi_aries_askar_checksum_method_encryptedbuffer_tag() != 5792 {
        return CheckVersionResult.apiChecksumMismatch
    }
    if uniffi_aries_askar_checksum_method_localkeyfactory_from_jwk() != 3782 {
        return CheckVersionResult.apiChecksumMismatch
    }
    if uniffi_aries_askar_checksum_method_localkeyfactory_from_jwk_slice() != 52225 {
        return CheckVersionResult.apiChecksumMismatch
    }
    if uniffi_aries_askar_checksum_method_localkeyfactory_from_public_bytes() != 49199 {
        return CheckVersionResult.apiChecksumMismatch
    }
    if uniffi_aries_askar_checksum_method_localkeyfactory_from_secret_bytes() != 16535 {
        return CheckVersionResult.apiChecksumMismatch
    }
    if uniffi_aries_askar_checksum_method_localkeyfactory_from_seed() != 48055 {
        return CheckVersionResult.apiChecksumMismatch
    }
    if uniffi_aries_askar_checksum_method_localkeyfactory_generate() != 30051 {
        return CheckVersionResult.apiChecksumMismatch
    }
    if uniffi_aries_askar_checksum_method_askarstoremanager_generate_raw_store_key() != 9452 {
        return CheckVersionResult.apiChecksumMismatch
    }
    if uniffi_aries_askar_checksum_method_askarstoremanager_open() != 44888 {
        return CheckVersionResult.apiChecksumMismatch
    }
    if uniffi_aries_askar_checksum_method_askarstoremanager_provision() != 52149 {
        return CheckVersionResult.apiChecksumMismatch
    }
    if uniffi_aries_askar_checksum_method_askarstoremanager_remove() != 1664 {
        return CheckVersionResult.apiChecksumMismatch
    }
    if uniffi_aries_askar_checksum_method_askarcrypto_box_open() != 34635 {
        return CheckVersionResult.apiChecksumMismatch
    }
    if uniffi_aries_askar_checksum_method_askarcrypto_box_seal() != 21906 {
        return CheckVersionResult.apiChecksumMismatch
    }
    if uniffi_aries_askar_checksum_method_askarcrypto_box_seal_open() != 63090 {
        return CheckVersionResult.apiChecksumMismatch
    }
    if uniffi_aries_askar_checksum_method_askarcrypto_crypto_box() != 19343 {
        return CheckVersionResult.apiChecksumMismatch
    }
    if uniffi_aries_askar_checksum_method_askarcrypto_random_nonce() != 64002 {
        return CheckVersionResult.apiChecksumMismatch
    }
    if uniffi_aries_askar_checksum_method_askarecdhes_decrypt_direct() != 51900 {
        return CheckVersionResult.apiChecksumMismatch
    }
    if uniffi_aries_askar_checksum_method_askarecdhes_derive_key() != 14697 {
        return CheckVersionResult.apiChecksumMismatch
    }
    if uniffi_aries_askar_checksum_method_askarecdhes_encrypt_direct() != 20454 {
        return CheckVersionResult.apiChecksumMismatch
    }
    if uniffi_aries_askar_checksum_method_askarecdhes_receiver_unwrap_key() != 28420 {
        return CheckVersionResult.apiChecksumMismatch
    }
    if uniffi_aries_askar_checksum_method_askarecdhes_sender_wrap_key() != 37744 {
        return CheckVersionResult.apiChecksumMismatch
    }
    if uniffi_aries_askar_checksum_method_askarecdh1pu_decrypt_direct() != 51975 {
        return CheckVersionResult.apiChecksumMismatch
    }
    if uniffi_aries_askar_checksum_method_askarecdh1pu_derive_key() != 11924 {
        return CheckVersionResult.apiChecksumMismatch
    }
    if uniffi_aries_askar_checksum_method_askarecdh1pu_encrypt_direct() != 40009 {
        return CheckVersionResult.apiChecksumMismatch
    }
    if uniffi_aries_askar_checksum_method_askarecdh1pu_receiver_unwrap_key() != 48319 {
        return CheckVersionResult.apiChecksumMismatch
    }
    if uniffi_aries_askar_checksum_method_askarecdh1pu_sender_wrap_key() != 50993 {
        return CheckVersionResult.apiChecksumMismatch
    }
    if uniffi__checksum_method_localkeyfactory_new() != 20118 {
        return CheckVersionResult.apiChecksumMismatch
    }
    if uniffi__checksum_method_askarstoremanager_new() != 18137 {
        return CheckVersionResult.apiChecksumMismatch
    }
    if uniffi__checksum_method_askarcrypto_new() != 33512 {
        return CheckVersionResult.apiChecksumMismatch
    }
    if uniffi__checksum_method_askarecdhes_new() != 11563 {
        return CheckVersionResult.apiChecksumMismatch
    }
    if uniffi__checksum_method_askarecdh1pu_new() != 37763 {
        return CheckVersionResult.apiChecksumMismatch
    }
    return CheckVersionResult.ok
}

private func uniffiCheckFfiVersionMismatch() {
    switch checkVersionResult {
    case .ok:
        break
    case .contractVersionMismatch:
        fatalError("UniFFI contract version mismatch: try cleaning and rebuilding your project")
    case .apiChecksumMismatch:
        fatalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
}
